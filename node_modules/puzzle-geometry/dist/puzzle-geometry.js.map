{"version":3,"sources":["webpack://puzzle-geometry/webpack/universalModuleDefinition","webpack://puzzle-geometry/webpack/bootstrap","webpack://puzzle-geometry/./src/Quat.ts","webpack://puzzle-geometry/./src/PlatonicGenerator.ts","webpack://puzzle-geometry/./src/Perm.ts","webpack://puzzle-geometry/./src/PermOriSet.ts","webpack://puzzle-geometry/./src/PuzzleGeometry.ts","webpack://puzzle-geometry/./src/SchreierSims.ts","webpack://puzzle-geometry/./src/index.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Quat","[object Object]","a_","b_","c_","d_","a","b","q","Math","hypot","sqrt","dot","normalize","acos","a00","a01","a02","a10","a11","a12","a20","a21","a22","mul","invrot","face","that","map","_","rotatepoint","cubie","rotateface","p2","p3","det","det3x3","abs","eps","p1","planes","intersect3","length","dt","x","faces","nfaces","j","inout","side","seen","nface","k","push","kk","vk","pt","smul","sum","rots","rotateplane","dist","random","len","PlatonicGenerator_PlatonicGenerator","s5","d36","PI","dx","dy","dd","cos","sin","ang","g","negns","wasseen","planerot","solvethreeplanes","changed","cross","Perm","join","Array","iota","floor","cyc","incyc","gcd","cs","lcm","PermOriSet_OrbitDef","size","mod","factorial","pow","OrbitsDef","orbitnames","orbitdefs","solved","movenames","moveops","forTwisty","result","orbits","toKsolveVS","isIdentity","toKsolve","neworbitnames","neworbitdefs","newsolved","newmoveops","om","du","DisjointUnion","perm","ori","union","keepori","duo","find","nontriv","multiple","h","no","on","nv","remapVS","remap","killOri","VisibleState","Transformation","pool","ri","rj","rm","reassemblySize","PermOriSet_Orbit","orimod","newPerm","newOri","done","v","undefined","toPerm","order","zeros","nextNew","reassign","ov","newori","PermOriSet_TransformationBase","newOrbits","inv","equal","perms","identicalPieces","super","internalMul","e","internalInv","heads","ah","bh","PuzzleGeometry_PuzzleGeometry","shape","cuts","optionlist","args","cmovesbyslice","verbose","allmoves","cornersets","centersets","edgesets","killorientation","optimize","scramble","fixPiece","fixedCubie","net","colors","faceorder","faceprecedence","outerblockmoves","vertexmoves","movelist","console","log","header","facenames","at","found","substr","startsWith","moveplanes","cubies","cube","octahedron","icosahedron","tetrahedron","dodecahedron","rotations","closure","baseplane","baseplanerot","uniqueplanes","baseplanes","basefacecount","defaultnets","defaultcolors","defaultfaceorders","baseface","getface","facenormal","makenormal","edgenormal","vertexnormal","cutplanes","normal","makecut","boundary","faceplanes","vertexnames","edgenames","edgesperface","searchaddelement","jj","midpoint","otherfaces","facelist","el","findelement","facenametoindex","faceindextoname","fi","ii","fn2","of","faceplane","facename","jjj","midpoint2","e1","e2","c1","c2","cornerfaces","st","geonormals","zero","edgedistance","vertexdistance","sameplane","cutfaces","stickersperface","shortedge","moveplanesets","faceside","facetocubies","findface","cm","centermassface","keyface","facelisthash","face2","facen","edgen","targvec","edgen2","plane","x0","sub","olen","y0","delta","cosr","sinr","x1","y1","expandfaces","qnormal","goodnormal","normalizeplane","sort","sizes","moverotations","angle","reverse","movesetorders","movesetgeos","p0","neg","pos","cubiehash","cubiekey","cubiekeys","suff","s2","keys","getfaceindex","facenum","divid","cmall","looplimit","u","mini","minf","temp","ocubie","slice","ofacelist","typenames","cubiesetnames","cubietypecounts","orbitoris","cubiesetnum","cubiesetnums","cubieordnums","cubieords","cubievaluemap","getcolorkey","cubienum","cubiesetcubies","cubiekeymap","cubievalueid","facecnt","typectr","typename","queue","qg","cind","cubiecolorkey","tq","findcubie","splitByFaceNames","mv","re","RegExp","match","grip","geo","msi","upperCaseGrip","toUpperCase","firstgrip","spinmatch","loslice","hislice","parseInt","amountstr","amount","substring","movesbyslice","moveplaneset","slicenum","slicecnts","axismoves","axiscmoves","sc","slicemoves","slicecmoves","cubiedone","fi2","parsedmovelist","parsemove","slices","parsedmove","msg","dep","trim","split","newr","set","skipbyori","comment","copyright","os","getOrbitsDef","mvs","movename","toGap","ip","bits","nbits","inverted","movenameFamily","movenamePrefix","hibit","String","toLowerCase","fortwisty","od","setmoves","setnames","setdefs","moveset","getmovesets","allbits","skipcubie","ind","moves","movesetgeo","movebits","mna","getmovename","moveorbits","oris","mperm","setnum","inc","oinc","mulScalar","ksolvemovenames","disp","orders","commutes","permA","permB","curlev","0","nextlev","uniq","sti","cnt","nst","showcanon","filter","Boolean","w","threed","extendedges","cosa","sina","ndx","drawedges","id","pts","color","needvertexgrips","neededgegrips","needfacegrips","genperms","polyn","getboundarygeometry","edges","minx","miny","maxx","maxy","f0","f1","f","es","min","max","xoff","yoff","geos","bg","edges2","initv","project2d","connectat","gfi","thisface","caf0","mp","epi","edgename","gf1","gf1i","otherface","getsolved","colormap","facegeo","hix","hiy","rot","sc2","mappt2d","fn","xmul","svg","cubieori","cubieord","svggrips","addgrip","onface","pt2","facecoords","ep","mpc","vp","html","4","6","8","12","20","F","D","L","R","U","B","M","N","C","A","E","BF","BR","BL","I","G","S","H","J","K","O","P","Q","FactoredNumber","mult","SchreierSims_SchreierSims","sgs","sgsi","sgslen","Tk","Tklen","knutha","knuthb","resolve","avgs","none","sz","tks","sollen","mults","lensum","multiply","avg","getsgs","__webpack_exports__"],"mappings":"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","file":"puzzle-geometry.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"puzzle-geometry\"] = factory();\n\telse\n\t\troot[\"puzzle-geometry\"] = factory();\n})(typeof self !== \"undefined\" ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","// We need a quaternion class.  We use this to represent rotations,\n// planes, and points.\n\nexport class Quat {\n   static eps = 1e-9 ;\n   a:number; b:number; c:number; d:number;\n   constructor(a_:number, b_:number, c_:number, d_:number) {\n      this.a = a_ ; this.b = b_ ; this.c = c_ ; this.d = d_ ;\n   }\n   mul(q:Quat):Quat { // Quaternion multiplication\n      return new Quat(\n           this.a*q.a-this.b*q.b-this.c*q.c-this.d*q.d,\n           this.a*q.b+this.b*q.a+this.c*q.d-this.d*q.c,\n           this.a*q.c-this.b*q.d+this.c*q.a+this.d*q.b,\n           this.a*q.d+this.b*q.c-this.c*q.b+this.d*q.a) ;\n   }\n   toString():string {\n      return 'Q[' + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ']' ;\n   }\n   dist(q:Quat):number { // Euclidean distance\n      return Math.hypot(this.a-q.a, this.b-q.b, this.c-q.c, this.d-q.d) ;\n   }\n   len():number { // Euclidean length\n      return Math.hypot(this.a, this.b, this.c, this.d) ;\n   }\n   cross(q:Quat):Quat { // cross product\n      return new Quat(0, this.c*q.d-this.d*q.c,\n                  this.d*q.b-this.b*q.d, this.b*q.c-this.c*q.b) ;\n   }\n   dot(q:Quat):number { // dot product of two quaternions\n      return this.b*q.b+this.c*q.c+this.d*q.d ;\n   }\n   normalize():Quat { // make the magnitude be 1\n      var d = Math.sqrt(this.dot(this)) ;\n      return new Quat(this.a/d, this.b/d, this.c/d, this.d/d) ;\n   }\n   makenormal():Quat { // make a normal vector from a plane or quat or point\n      return new Quat(0, this.b, this.c, this.d).normalize() ;\n   }\n   normalizeplane():Quat { // normalize a plane\n      var d = Math.hypot(this.b, this.c, this.d) ;\n      return new Quat(this.a/d, this.b/d, this.c/d, this.d/d) ;\n   }\n   smul(m:number):Quat { // scalar multiplication\n      return new Quat(this.a*m, this.b*m, this.c*m, this.d*m) ;\n   }\n   sum(q:Quat):Quat { // quaternion sum\n      return new Quat(this.a+q.a, this.b+q.b, this.c+q.c, this.d+q.d) ;\n   }\n   sub(q:Quat):Quat { // difference\n      return new Quat(this.a-q.a, this.b-q.b, this.c-q.c, this.d-q.d) ;\n   }\n   angle():number { // quaternion angle\n      return 2 * Math.acos(this.a) ;\n   }\n   invrot():Quat { // quaternion inverse rotation\n      return new Quat(this.a, -this.b, -this.c, -this.d) ;\n   }\n   det3x3(a00:number, a01:number, a02:number, a10:number, a11:number,\n          a12:number, a20:number, a21:number, a22:number):number {\n      // 3x3 determinant\n      return a00 * (a11 * a22 - a12 * a21) +\n             a01 * (a12 * a20 - a10 * a22) +\n             a02 * (a10 * a21 - a11 * a20) ;\n   }\n   rotateplane(q:Quat):Quat { // rotate a plane using a quaternion\n      var t = q.mul(new Quat(0, this.b, this.c, this.d)).mul(q.invrot()) ;\n      t.a = this.a ;\n      return t ;\n   }\n   rotatepoint(q:Quat):Quat { // rotate a point\n      return q.mul(this).mul(q.invrot()) ;\n   }\n   rotateface(face:Array<Quat>):Array<Quat> { // rotate a face by this Q.\n      var that = this ;\n      return face.map((_:Quat)=>_.rotatepoint(that)) ;\n   }\n   rotatecubie(cubie:Array<Array<Quat>>):Array<Array<Quat>> { // rotate a cubie by this Q.\n      var that = this ;\n      return cubie.map((_:Array<Quat>)=>that.rotateface(_)) ;\n   }\n   intersect3(p2:Quat, p3:Quat) { // intersect three planes if there is one\n      var det = this.det3x3(this.b, this.c, this.d,\n                            p2.b, p2.c, p2.d,\n                            p3.b, p3.c, p3.d) ;\n      if (Math.abs(det) < Quat.eps)\n         return false ;\n      return new Quat(0,\n                  this.det3x3(this.a, this.c, this.d,\n                              p2.a, p2.c, p2.d, p3.a, p3.c, p3.d)/det,\n                  this.det3x3(this.b, this.a, this.d,\n                              p2.b, p2.a, p2.d, p3.b, p3.a, p3.d)/det,\n                  this.det3x3(this.b, this.c, this.a,\n                              p2.b, p2.c, p2.a, p3.b, p3.c, p3.a)/det) ;\n   }\n   solvethreeplanes(p1:number, p2:number, p3:number, planes:Array<Quat>):any {\n   // find intersection of three planes but only if interior\n   // Takes three indices into a plane array, and returns the point at the\n   // intersection of all three, but only if it is internal to all planes.\n      var p = planes[p1].intersect3(planes[p2], planes[p3]) ;\n      if (!p)\n         return p ;\n      for (var i=0; i<planes.length; i++) {\n         if (i != p1 && i != p2 && i != p3) {\n            var dt = planes[i].b * p.b + planes[i].c * p.c + planes[i].d * p.d ;\n            if ((planes[i].a > 0 && dt > planes[i].a) ||\n                (planes[i].a < 0 && dt < planes[i].a))\n               return false ;\n         }\n      }\n      return p ;\n   }\n   side(x:number):number {\n   // is this point close to the origin, or on one or the other side?\n      if (x > Quat.eps)\n         return 1 ;\n      if (x < -Quat.eps)\n         return -1 ;\n      return 0 ;\n   }\n   cutfaces(faces:Array<Array<Quat>>):Array<Array<Quat>> { \n     // Cut a set of faces by a plane and return new set\n      var that = this ; // welcome to Javascript\n      var d = this.a ;\n      var nfaces = [] ;\n      for (var j=0; j<faces.length; j++) {\n         var face = faces[j] ;\n         var inout = face.map((_:Quat)=>that.side(_.dot(that)-d)) ;\n         var seen = 0 ;\n         for (var i=0; i<inout.length; i++) {\n            seen |= 1<<(inout[i]+1) ;\n         }\n         if ((seen & 5) == 5) { // saw both sides\n            for (var s=-1; s<=1; s += 2) {\n               var nface = [] ;\n               for (var k=0; k<face.length; k++) {\n                  if (inout[k] == s || inout[k] == 0) {\n                     nface.push(face[k]) ;\n                  }\n                  var kk = (k + 1) % face.length ;\n                  if (inout[k] + inout[kk] == 0 && inout[k] != 0) {\n                     var vk = face[k].dot(this) - d ;\n                     var vkk = face[kk].dot(this) - d ;\n                     var r = vk / (vk - vkk) ;\n                     var pt = face[k].smul(1-r).sum(face[kk].smul(r)) ;\n                     nface.push(pt) ;\n                  }\n               }\n               nfaces.push(nface) ;\n            }\n         } else { // no split\n            nfaces.push(face) ;\n         }\n      }\n      return nfaces ;\n   }\n   faceside(face:Array<Quat>):number { // which side of a plane is a face on?\n      var d = this.a ;\n      for (var i=0; i<face.length; i++) {\n         var s = this.side(face[i].dot(this)-d) ;\n         if (s != 0)\n            return s ;\n      }\n      throw \"Could not determine side of plane in faceside\" ;\n   }\n   static expandfaces(rots:Array<Quat>, faces:Array<Array<Quat>>):Array<Array<Quat>> {\n      // given a set of faces, expand by rotation set\n      var nfaces = [] ;\n      for (var i=0; i<rots.length; i++) {\n         for (var k=0; k<faces.length; k++) {\n            var face = faces[k] ;\n            var nface = [] ;\n            for (var j=0; j<face.length; j++)\n               nface.push(face[j].rotateplane(rots[i])) ;\n            nfaces.push(nface) ;\n         }\n      }\n      return nfaces ;\n   }\n   sameplane(p:Quat):boolean { // are two planes the same?\n      var a = this.normalize() ;\n      var b = p.normalize() ;\n      return a.dist(b) < Quat.eps || a.dist(b.smul(-1)) < Quat.eps ;\n   }\n   static centermassface(face:Array<Quat>):Quat {\n      // calculate a center of a face by averaging points\n      var s = new Quat(0, 0, 0, 0) ;\n      for (var i=0; i<face.length; i++)\n         s = s.sum(face[i]) ;\n      return s.smul(1.0/face.length) ;\n   }\n   makecut(r:number):Quat { // make a cut from a normal vector\n      return new Quat(r, this.b, this.c, this.d) ;\n   }\n   static random():Quat { // generate a random quat\n      var q = new Quat(Math.random()*2-1, Math.random()*2-1,\n                       Math.random()*2-1, Math.random()*2-1) ;\n      return q.smul(1/q.len()) ;\n   }\n}\n","import { Quat } from \"./Quat\" ;\n\n// Next we define a class that yields quaternion generators for each of\n// the five platonic solids.  The quaternion generators chosen are\n// chosen specifically so that the first quaternion doubles as a plane\n// description that yields the given Platonic solid (so for instance, the\n// cubical group and octahedral group are identical in math, but we\n// give distinct representations choosing the first quaternion so that\n// we get the desired figure.)  Our convention is one vertex of the\n// shape points precisely down.\n\n// This class is static.\n\nexport class PlatonicGenerator {\n   static eps = 1e-9 ;\n   static cube():Array<Quat> {\n      var s5 = Math.sqrt(0.5) ;\n      return [new Quat(s5, s5, 0, 0), new Quat(s5, 0, s5, 0)] ;\n   }\n   static tetrahedron():Array<Quat> {\n      return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(0.5, 0.5, 0.5, -0.5)] ;\n   }\n   static dodecahedron():Array<Quat> {\n      var d36 = 2 * Math.PI / 10 ;\n      var dx = 0.5 + 0.3 * Math.sqrt(5) ;\n      var dy = 0.5 + 0.1 * Math.sqrt(5) ;\n      var dd = Math.sqrt(dx*dx+dy*dy) ;\n      dx /= dd ;\n      dy /= dd ;\n      return [new Quat(Math.cos(d36), dx*Math.sin(d36), dy*Math.sin(d36), 0),\n              new Quat(0.5, 0.5, 0.5, 0.5)] ;\n   }\n   static icosahedron():Array<Quat> {\n      var dx = 1/6 + Math.sqrt(5)/6 ;\n      var dy = 2/3 + Math.sqrt(5)/3 ;\n      var dd = Math.sqrt(dx*dx+dy*dy) ;\n      dx /= dd ;\n      dy /= dd ;\n      var ang = 2 * Math.PI / 6 ;\n      return [new Quat(Math.cos(ang), dx*Math.sin(ang), dy*Math.sin(ang), 0),\n              new Quat(Math.cos(ang), -dx*Math.sin(ang), dy*Math.sin(ang), 0)] ;\n   }\n   static octahedron():Array<Quat> {\n      var s5 = Math.sqrt(0.5) ;\n      return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(s5, 0, 0, s5)] ;\n   }\n   static closure(g:Array<Quat>):Array<Quat> {\n   // compute the closure of a set of generators\n   // This is quadratic in the result size.  Also, it has no protection\n   // against you providing a bogus set of generators that would generate\n   // an infinite group.\n      var q = [new Quat(1, 0, 0, 0)] ;\n      for (var i=0; i<q.length; i++) {\n         for (var j=0; j<g.length; j++) {\n            var ns = g[j].mul(q[i]) ;\n            var negns = ns.smul(-1) ;\n            var wasseen = false ;\n            for (var k=0; k<q.length; k++) {\n               if (ns.dist(q[k]) < PlatonicGenerator.eps ||\n                   negns.dist(q[k]) < PlatonicGenerator.eps) {\n                  wasseen = true ;\n                  break ;\n               }\n            }\n            if (!wasseen) {\n               q.push(ns) ;\n            }\n         }\n      }\n      return q ;\n   }\n   static uniqueplanes(p:Quat,g:Array<Quat>):Array<Quat> {\n   // compute unique plane rotations\n   // given a rotation group and a plane, find the rotations that\n   // generate unique planes.  This is quadratic in the return size.\n      var planes = [] ;\n      var planerot = [] ;\n      for (var i=0; i<g.length; i++) {\n         var p2 = p.rotateplane(g[i]) ;\n         var wasseen = false ;\n         for (var j=0; j<planes.length; j++) {\n            if (p2.dist(planes[j]) < PlatonicGenerator.eps) {\n               wasseen = true ;\n               break ;\n            }\n         }\n         if (!wasseen) {\n            planes.push(p2) ;\n            planerot.push(g[i]) ;\n         }\n      }\n      return planerot ;\n   }\n   static getface(planes:Array<Quat>):Array<Quat> {\n   // compute a face given a set of planes\n   // The face returned will be a set of points that lie in the first plane\n   // in the given array, that are on the surface of the polytope defined\n   // by all the planes, and will be returned in clockwise order.\n   // This is O(planes^2 * return size + return_size^2).\n      var face = [] ;\n      for (var i=1; i<planes.length; i++) {\n         for (var j=i+1; j<planes.length; j++) {\n            var p = planes[0].solvethreeplanes(0, i, j, planes) ;\n            if (p) {\n               var wasseen = false ;\n               for (var k=0; k<face.length; k++) {\n                  if (p.dist(face[k]) < PlatonicGenerator.eps) {\n                     wasseen = true ;\n                     break ;\n                  }\n               }\n               if (!wasseen)\n                  face.push(p) ;\n            }\n         }\n      }\n      while (true) {\n         var changed = false ;\n         for (var i=0; i<face.length; i++) {\n            var j = (i + 1) % face.length ;\n            if (planes[0].dot(face[i].cross(face[j])) < 0) {\n               var t:Quat = face[i] ;\n               face[i] = face[j] ;\n               face[j] = t ;\n               changed = true ;\n            }\n         }\n         if (!changed)\n            break ;\n      }\n      return face ;\n   }\n}\n","export class Perm {\n   n:number ;        // length\n   p:Array<number> ; // The permutation itself\n   constructor(a:Array<number>) {\n      this.n = a.length ;\n      this.p = a ;\n   }\n   toString():string { // stringify\n      return 'Perm[' + this.p.join(' ') + ']' ;\n   }\n   mul(p2:Perm):Perm { // multiply\n      var c:Array<number> = Array(this.n) ;\n      for (var i=0; i<this.n; i++)\n         c[i] = p2.p[this.p[i]] ;\n      return new Perm(c) ;\n   }\n   rmul(p2:Perm):Perm { // multiply the other way\n      var c = Array(this.n) ;\n      for (var i=0; i<this.n; i++)\n         c[i] = this.p[p2.p[i]] ;\n      return new Perm(c) ;\n   }\n   inv():Perm {\n      var c = Array(this.n) ;\n      for (var i=0; i<this.n; i++)\n         c[this.p[i]] = i ;\n      return new Perm(c) ;\n   }\n   static zeros(n:number):Array<number> {\n      var c = Array(n) ;\n      for (var i=0; i<n; i++)\n         c[i] = 0 ;\n      return c ;\n   }\n   static iota(n:number):Array<number> {\n      var c = Array(n) ;\n      for (var i=0; i<n; i++)\n         c[i] = i ;\n      return c ;\n   }\n   static e(n:number):Perm {\n      return new Perm(Perm.iota(n)) ;\n   }\n   static random(n:number) { // random\n      var c = Array(n) ;\n      for (var i=0; i<n; i++)\n         c[i] = i ;\n      for (var i=0; i<n; i++) {\n         var j = i + Math.floor((n-i)*Math.random()) ;\n         var t = c[i] ;\n         c[i] = c[j] ;\n         c[j] = t ;\n      }\n      return new Perm(c) ;\n   }\n   compareTo(p2:Perm):number { // comparison\n      for (var i=0; i<this.n; i++)\n         if (this.p[i] != p2.p[i])\n            return this.p[i]-p2.p[i] ;\n      return 0 ;\n   }\n   toGap():string {\n      var cyc = new Array<string>() ;\n      var seen = new Array<boolean>(this.n) ;\n      for (var i=0; i<this.p.length; i++) {\n         if (seen[i] || this.p[i] == i)\n            continue ;\n         var incyc = new Array<number>() ;\n         for (var j=i; !seen[j]; j=this.p[j]) {\n            incyc.push(1+j) ;\n            seen[j] = true ;\n         }\n         cyc.push(\"(\"+incyc.join(\",\")+\")\") ;\n      }\n      return cyc.join(\"\") ;\n   }\n   static factorial(a:number):number {\n      var r = 1 ;\n      while (a > 1) {\n         r *= a ;\n         a-- ;\n      }\n      return r ;\n   }\n   static gcd(a:number, b:number):number {\n      if (a > b) {\n         var t = a ;\n         a = b ;\n         b = t ;\n      }\n      while (a > 0) {\n         var m = b % a ;\n         b = a ;\n         a = m ;\n      }\n      return b ;\n   }\n   static lcm(a:number, b:number):number {\n      return a / Perm.gcd(a, b) * b ;\n   }\n   order():number {\n      var r = 1 ;\n      var seen = new Array<boolean>(this.n) ;\n      for (var i=0; i<this.p.length; i++) {\n         if (seen[i] || this.p[i] == i)\n            continue ;\n         var cs = 0 ;\n         for (var j=i; !seen[j]; j=this.p[j]) {\n            cs++ ;\n            seen[j] = true ;\n         }\n         r = Perm.lcm(r, cs) ;\n      }\n      return r ;\n   }\n}\n","import { Perm } from \"./Perm\" ;\nexport class OrbitDef {\n   constructor(public size:number, public mod:number) {}\n   reassemblySize():number {\n      return Perm.factorial(this.size)*Math.pow(this.mod, this.size) ;\n   }\n}\nexport class OrbitsDef {\n   constructor(public orbitnames:Array<string>,\n               public orbitdefs:Array<OrbitDef>,\n               public solved:VisibleState,\n               public movenames:Array<string>,\n               public moveops:Array<Transformation>) {}\n   toKsolve(name:string, forTwisty:boolean):Array<string> {\n      var result = [] ;\n      result.push(\"Name \" + name) ;\n      result.push(\"\") ;\n      for (var i=0; i<this.orbitnames.length; i++)\n         result.push(\"Set \" + this.orbitnames[i] + \" \" +\n                     this.orbitdefs[i].size + \" \" + this.orbitdefs[i].mod) ;\n      result.push(\"\") ;\n      result.push(\"Solved\") ;\n      for (var i=0; i<this.orbitnames.length; i++) {\n         result.push(this.orbitnames[i]) ;\n         var o = this.solved.orbits[i].toKsolveVS() ;\n         result.push(o[0]) ;\n         result.push(o[1]) ;\n      }\n      result.push(\"End\") ;\n      result.push(\"\") ;\n      for (var i=0; i<this.movenames.length; i++) {\n         result.push(\"Move \" + this.movenames[i]) ;\n         for (var j=0; j<this.orbitnames.length; j++) {\n            if (!forTwisty && this.moveops[i].orbits[j].isIdentity())\n               continue ;\n            result.push(this.orbitnames[j]) ;\n            var o = this.moveops[i].orbits[j].toKsolve() ;\n            result.push(o[0]) ;\n            result.push(o[1]) ;\n         }\n         result.push(\"End\") ;\n         result.push(\"\") ;\n      }\n      // extra blank line on end lets us use join(\"\\n\") to terminate all\n      return result ;\n   }\n   optimize():OrbitsDef {\n      var neworbitnames:Array<string> = [] ;\n      var neworbitdefs:Array<OrbitDef> = [] ;\n      var newsolved:Array<Orbit> = [] ;\n      var newmoveops:Array<Array<Orbit>> = [] ;\n      for (var j=0; j<this.moveops.length; j++)\n         newmoveops.push([]) ;\n      for (var i=0; i<this.orbitdefs.length; i++) {\n         var om = this.orbitdefs[i].mod ;\n         var n = this.orbitdefs[i].size ;\n         var du = new DisjointUnion(n) ;\n         var changed = new Array<boolean>(this.orbitdefs[i].size) ;\n         for (var k=0; k<n; k++)\n            changed[k] = false ;\n         for (var j=0; j<this.moveops.length; j++)\n            for (var k=0; k<n; k++)\n               if (this.moveops[j].orbits[i].perm[k] != k ||\n                   this.moveops[j].orbits[i].ori[k] != 0) {\n                  changed[k] = true ;\n                  du.union(k, this.moveops[j].orbits[i].perm[k]) ;\n               }\n         var keepori = true ;\n         // right now we kill ori only if solved is unique and\n         // if we can kill it completely.  This is not all the optimization\n         // we can perform.\n         if (om > 1) {\n            keepori = false ;\n            var duo = new DisjointUnion(this.orbitdefs[i].size * om) ;\n            for (var j=0; j<this.moveops.length; j++)\n               for (var k=0; k<n; k++)\n                  if (this.moveops[j].orbits[i].perm[k] != k ||\n                      this.moveops[j].orbits[i].ori[k] != 0)\n                     for (var o=0; o<om; o++)\n                        duo.union(k*om+o, this.moveops[j].orbits[i].perm[k]*om+\n                                      (o+this.moveops[j].orbits[i].ori[k])%om) ;\n            for (var j=0; !keepori && j<n; j++)\n               for (var o=1; o<om; o++)\n                  if (duo.find(j*om) == duo.find(j*om+o))\n                     keepori = true ;\n            for (var j=0; !keepori && j<n; j++)\n               for (var k=0; k<j; k++)\n                  if (this.solved.orbits[i].perm[j] ==\n                      this.solved.orbits[i].perm[k])\n                     keepori = true ;\n         }\n         // is there just one result set, or more than one?\n         var nontriv = -1 ;\n         var multiple = false ;\n         for (var j=0; j<this.orbitdefs[i].size; j++)\n            if (changed[j]) {\n               var h = du.find(j) ;\n               if (nontriv < 0)\n                  nontriv = h ;\n               else if (nontriv != h)\n                  multiple = true ;\n            }\n         for (var j=0; j<this.orbitdefs[i].size; j++) {\n            if (!changed[j])\n               continue ;\n            var h = du.find(j) ;\n            if (h != j)\n               continue ;\n            var no:Array<number> = [] ;\n            var on:Array<number> = [] ;\n            var nv = 0 ;\n            for (var k=0; k<this.orbitdefs[i].size; k++)\n               if (du.find(k) == j) {\n                  no[nv] = k ;\n                  on[k] = nv ;\n                  nv++ ;\n               }\n            if (multiple)\n               neworbitnames.push(this.orbitnames[i] + \"_p\" + j) ;\n            else\n               neworbitnames.push(this.orbitnames[i]) ;\n            if (keepori) {\n               neworbitdefs.push(new OrbitDef(nv, this.orbitdefs[i].mod)) ;\n               newsolved.push(this.solved.orbits[i].remapVS(no, nv)) ;\n               for (var k=0; k<this.moveops.length; k++)\n                  newmoveops[k].push(this.moveops[k].orbits[i].remap(no, on, nv)) ;\n            } else {\n               neworbitdefs.push(new OrbitDef(nv, 1)) ;\n               newsolved.push(this.solved.orbits[i].remapVS(no, nv).killOri()) ;\n               for (var k=0; k<this.moveops.length; k++)\n                  newmoveops[k].push(this.moveops[k].orbits[i].\n                                                  remap(no, on, nv).killOri()) ;\n            }\n         }\n      }\n      return new OrbitsDef(neworbitnames, neworbitdefs,\n                           new VisibleState(newsolved), this.movenames,\n                           newmoveops.map((_)=>new Transformation(_))) ;\n   }\n   // generate a new \"solved\" position based on scrambling\n   // we use an algorithm that should be faster for large puzzles than\n   // just picking random moves.\n   scramble(n:number):void {\n      var pool:Array<Transformation> = [] ;\n      for (var i=0; i<this.moveops.length; i++)\n         pool[i] = this.moveops[i] ;\n      for (var i=0; i<pool.length; i++) {\n         var j = Math.floor(Math.random() * pool.length) ;\n         var t = pool[i] ;\n         pool[i] = pool[j] ;\n         pool[j] = t ;\n      }\n      if (n < pool.length)\n         n = pool.length ;\n      for (var i=0; i<n; i++) {\n         var ri = Math.floor(Math.random() * pool.length) ;\n         var rj = Math.floor(Math.random() * pool.length) ;\n         var rm = Math.floor(Math.random() * this.moveops.length) ;\n         pool[ri] = pool[ri].mul(pool[rj]).mul(this.moveops[rm]) ;\n         if (Math.random() < 0.1) // break up parity\n            pool[ri] = pool[ri].mul(this.moveops[rm]) ;\n      }\n      var s = pool[0] ;\n      for (var i=1; i<pool.length; i++)\n         s = s.mul(pool[i]) ;\n      this.solved = this.solved.mul(s) ;\n   }\n   reassemblySize():number {\n      var n = 1 ;\n      for (var i=0; i<this.orbitdefs.length; i++)\n         n *= this.orbitdefs[i].reassemblySize() ;\n      return n ;\n   }\n}\nexport class Orbit {\n   constructor(public perm:Array<number>, public ori:Array<number>,\n               public orimod:number) {}\n   mul(b:Orbit):Orbit {\n      var n = this.perm.length ;\n      var newPerm = new Array<number>(n) ;\n      var newOri = new Array<number>(n) ;\n      for (var i=0; i<n; i++) {\n         newPerm[i] = this.perm[b.perm[i]] ;\n         newOri[i] = (this.ori[b.perm[i]]+b.ori[i])%this.orimod ;\n      }\n      return new Orbit(newPerm, newOri, this.orimod) ;\n   }\n   inv():Orbit {\n      var n = this.perm.length ;\n      var newPerm = new Array<number>(n) ;\n      var newOri = new Array<number>(n) ;\n      for (var i=0; i<n; i++) {\n         newPerm[this.perm[i]] = i ;\n         newOri[this.perm[i]] = (this.orimod-this.ori[i])%this.orimod ;\n      }\n      return new Orbit(newPerm, newOri, this.orimod) ;\n   }\n   equal(b:Orbit):boolean {\n      var n = this.perm.length ;\n      for (var i=0; i<n; i++)\n         if (this.perm[i] != b.perm[i] || this.ori[i] != b.ori[i])\n            return false ;\n      return true ;\n   }\n   // in-place mutator\n   killOri():this {\n      var n = this.perm.length ;\n      for (var i=0; i<n; i++)\n         this.ori[i] = 0 ;\n      this.orimod = 1 ;\n      return this ;\n   }\n   toPerm():Perm {\n      var o = this.orimod ;\n      if (o == 1)\n         return new Perm(this.perm) ;\n      var n = this.perm.length ;\n      var newPerm = new Array<number>(n*o) ;\n      for (var i=0; i<n; i++)\n         for (var j=0; j<o; j++)\n            newPerm[i*o+j] = o*this.perm[i]+(this.ori[i]+j)%o ;\n      return new Perm(newPerm) ;\n   }\n   // returns tuple of sets of identical pieces in this orbit\n   identicalPieces():Array<Array<number>> {\n      var done:Array<boolean> = [] ;\n      var n = this.perm.length ;\n      var r:Array<Array<number>> = [] ;\n      for (var i=0; i<n; i++) {\n         var v = this.perm[i] ;\n         if (done[v] == undefined) {\n            var s:Array<number> = [i] ;\n            done[v] = true ;\n            for (var j=i+1; j<n; j++)\n               if (this.perm[j] == v)\n                  s.push(j) ;\n            r.push(s) ;\n         }\n      }\n      return r ;\n   }\n   order():number { // can be made more efficient\n      return this.toPerm().order() ;\n   }\n   static e(n:number, mod:number):Orbit {\n      return new Orbit(Perm.iota(n), Perm.zeros(n), mod) ;\n   }\n   isIdentity():boolean {\n      var n = this.perm.length ;\n      for (var i=0; i<n; i++)\n         if (this.perm[i] != i || this.ori[i] != 0)\n            return false ;\n      return true ;\n   }\n   remap(no:Array<number>, on:Array<number>, nv:number):Orbit {\n      var newPerm = new Array<number>(nv) ;\n      var newOri = new Array<number>(nv) ;\n      for (var i=0; i<nv; i++) {\n         newPerm[i] = on[this.perm[no[i]]] ;\n         newOri[i] = this.ori[no[i]] ;\n      }\n      return new Orbit(newPerm, newOri, this.orimod) ;\n   }\n   remapVS(no:Array<number>, nv:number):Orbit {\n      var newPerm = new Array<number>(nv) ;\n      var newOri = new Array<number>(nv) ;\n      var nextNew = 0 ;\n      var reassign = [] ;\n      for (var i=0; i<nv; i++) {\n         var ov = this.perm[no[i]] ;\n         if (reassign[ov] == undefined)\n            reassign[ov] = nextNew++ ;\n         newPerm[i] = reassign[ov] ;\n         newOri[i] = this.ori[no[i]] ;\n      }\n      return new Orbit(newPerm, newOri, this.orimod) ;\n   }\n   toKsolveVS():Array<string> {\n      return [this.perm.map((_:number)=>_+1).join(\" \"), this.ori.join(\" \")] ;\n   }\n   toKsolve():Array<string> {\n      var newori = new Array<number>(this.ori.length) ;\n      for (var i=0; i<newori.length; i++)\n         newori[this.perm[i]] = this.ori[i] ;\n      return [this.perm.map((_:number)=>_+1).join(\" \"), newori.join(\" \")] ;\n   }\n}\nexport class TransformationBase {\n   constructor(public orbits:Array<Orbit>) {}\n   internalMul(b:TransformationBase):Array<Orbit> {\n      var newOrbits:Array<Orbit> = [] ;\n      for (var i=0; i<this.orbits.length; i++)\n         newOrbits.push(this.orbits[i].mul(b.orbits[i])) ;\n      return newOrbits ;\n   }\n   internalInv():Array<Orbit> {\n      var newOrbits:Array<Orbit> = [] ;\n      for (var i=0; i<this.orbits.length; i++)\n         newOrbits.push(this.orbits[i].inv()) ;\n      return newOrbits ;\n   }\n   equal(b:TransformationBase):boolean {\n      for (var i=0; i<this.orbits.length; i++)\n         if (!this.orbits[i].equal(b.orbits[i]))\n            return false ;\n      return true ;\n   }\n   killOri():this {\n      for (var i=0; i<this.orbits.length; i++)\n         this.orbits[i].killOri() ;\n      return this ;\n   }\n   toPerm():Perm {\n      var perms = new Array<Perm>() ;\n      var n = 0 ;\n      for (var i=0; i<this.orbits.length; i++) {\n         var p = this.orbits[i].toPerm() ;\n         perms.push(p) ;\n         n += p.n ;\n      }\n      var newPerm = new Array<number>(n) ;\n      n = 0 ;\n      for (var i=0; i<this.orbits.length; i++) {\n         var p = perms[i] ;\n         for (var j=0; j<p.n; j++)\n            newPerm[n+j] = n + p.p[j] ;\n         n += p.n ;\n      }\n      return new Perm(newPerm) ;\n   }\n   identicalPieces():Array<Array<number>> {\n      var r:Array<Array<number>> = [] ;\n      var n = 0 ;\n      for (var i=0; i<this.orbits.length; i++) {\n         var o = this.orbits[i].orimod ;\n         var s = this.orbits[i].identicalPieces() ;\n         for (var j=0; j<s.length; j++)\n            r.push(s[j].map((_)=>_*o+n)) ;\n         n += o * this.orbits[i].perm.length ;\n      }\n      return r ;\n   }\n   order():number {\n      var r = 1 ;\n      for (var i=0; i<this.orbits.length; i++)\n         r = Perm.lcm(r, this.orbits[i].order()) ;\n      return r ;\n   }\n}\nexport class Transformation extends TransformationBase {\n   constructor(orbits:Array<Orbit>) {\n      super(orbits) ;\n   }\n   mul(b:Transformation):Transformation {\n      return new Transformation(this.internalMul(b)) ;\n   }\n   mulScalar(n:number):Transformation {\n      if (n == 0)\n         return this.e() ;\n      var t:Transformation = this ;\n      if (n < 0) {\n         t = t.inv() ;\n         n = - n ;\n      }\n      while ((n & 1) == 0) {\n         t = t.mul(t) ;\n         n >>= 1 ;\n      }\n      if (n == 1)\n         return t ;\n      var s = t ;\n      var r = this.e() ;\n      while (n > 0) {\n         if (n & 1)\n            r = r.mul(s) ;\n         if (n > 1)\n            s = s.mul(s) ;\n         n >>= 1 ;\n      }\n      return r ;\n   }\n   inv():Transformation {\n      return new Transformation(this.internalInv()) ;\n   }\n   e():Transformation {\n      return new Transformation(this.orbits.map(\n         (_:Orbit)=>Orbit.e(_.perm.length,_.orimod))) ;\n   }\n}\nexport class VisibleState extends TransformationBase {\n   constructor(orbits:Array<Orbit>) {\n      super(orbits) ;\n   }\n   mul(b:Transformation):VisibleState {\n      return new VisibleState(this.internalMul(b)) ;\n   }\n}\n//  Disjoint set union implementation.\nclass DisjointUnion {\n   heads:Array<number> ;\n   constructor(public n:number) {\n      this.heads = new Array<number>(n) ;\n      for (var i=0; i<n; i++)\n         this.heads[i] = i ;\n   }\n   find(v:number):number {\n      var h = this.heads[v] ;\n      if (this.heads[h] == h)\n         return h ;\n      h = this.find(this.heads[h]) ;\n      this.heads[v] = h ;\n      return h ;\n   }\n   union(a:number, b:number):void {\n      var ah = this.find(a) ;\n      var bh = this.find(b) ;\n      if (ah < bh) {\n         this.heads[bh] = ah ;\n      } else if (ah > bh) {\n         this.heads[ah] = bh ;\n      }\n   }\n}\nexport function showcanon(g:OrbitsDef,disp:(s:string)=>void):void {\n   // show information for canonical move derivation\n   var n = g.moveops.length ;\n   if (n > 30)\n      throw \"Canon info too big for bitmask\" ;\n   var orders = [] ; \n   var commutes = [] ;\n   for (var i=0; i<n; i++) {\n      var permA = g.moveops[i] ;\n      orders.push(permA.order()) ;\n      var bits = 0 ;\n      for (var j=0; j<n; j++) {\n         if (j == i) \n            continue ;\n         var permB = g.moveops[j] ;\n         if (permA.mul(permB).equal(permB.mul(permA))) {\n            bits |= 1<<j ;\n         }\n      }\n      commutes.push(bits) ;\n   }\n   var curlev:any = {} ;\n   curlev[0] = 1 ;\n   for (var d=0; d<100; d++) {\n      var sum = 0 ;\n      var nextlev:any = {} ;\n      var uniq = 0 ;\n      for (var sti in curlev) {\n         var st = +sti ; // string to number\n         var cnt = curlev[st] ;\n         sum += cnt ;\n         uniq++ ; \n         for (var mv=0; mv<orders.length; mv++) {\n            if (((st >> mv) & 1) == 0 && \n                (st & commutes[mv] & ((1 << mv) - 1)) == 0) {\n               var nst = (st & commutes[mv]) | (1 << mv) ;\n               if (nextlev[nst] == undefined)\n                  nextlev[nst] = 0 ;\n               nextlev[nst] += (orders[mv]-1) * cnt ;\n            }\n         }\n      }\n      disp(\"\" + d + \": canonseq \" + sum + \" states \" + uniq) ;\n      curlev = nextlev ;\n   }\n}\n// This is a less effective canonicalization (that happens to work fine\n// for the 3x3x3).  We include this only for comparison.\nexport function showcanon0(g:OrbitsDef,disp:(s:string)=>void):void {\n   // show information for canonical move derivation\n   var n = g.moveops.length ;\n   if (n > 30)\n      throw \"Canon info too big for bitmask\" ;\n   var orders = [] ; \n   var commutes = [] ;\n   for (var i=0; i<n; i++) {\n      var permA = g.moveops[i] ;\n      orders.push(permA.order()) ;\n      var bits = 0 ;\n      for (var j=0; j<n; j++) {\n         if (j == i) \n            continue ;\n         var permB = g.moveops[j] ;\n         if (permA.mul(permB).equal(permB.mul(permA))) {\n            bits |= 1<<j ;\n         }\n      }\n      commutes.push(bits) ;\n   }\n   var curlev:any = {} ;\n   disp(\"\" + 0 + \": canonseq \" + 1) ;\n   for (var x=0; x<orders.length; x++) {\n      curlev[x] = orders[x]-1 ;\n   }\n   for (var d=1; d<100; d++) {\n      var sum = 0 ;\n      var nextlev:any = {} ;\n      var uniq = 0 ;\n      for (var sti in curlev) {\n         var st = +sti ; // string to number\n         var cnt = curlev[st] ;\n         sum += cnt ;\n         uniq++ ; \n         for (var mv=0; mv<orders.length; mv++) {\n            if (mv == st || ((commutes[mv] & (1 << st)) && mv < st))\n               continue ;\n            if (nextlev[mv] == undefined)\n               nextlev[mv] = 0 ;\n            nextlev[mv] += (orders[mv]-1) * cnt ;\n         }\n      }\n      disp(\"\" + d + \": canonseq \" + sum + \" states \" + uniq) ;\n      curlev = nextlev ;\n   }\n}\n","import { Quat } from \"./Quat\" ;\nimport { PlatonicGenerator } from \"./PlatonicGenerator\" ;\nimport { Perm } from \"./Perm\" ;\nimport { OrbitDef, OrbitsDef, Orbit, Transformation, VisibleState, showcanon }\n                                                          from \"./PermOriSet\" ;\n\n//  Now we have a geometry class that does the 3D goemetry to calculate\n//  individual sticker information from a Platonic solid and a set of\n//  cuts.  The cuts must have the same symmetry as the Platonic solid;\n//  we even restrict them further to be either vertex-normal,\n//  edge-normal, or face-parallel cuts.  Right now our constructor takes\n//  a character solid indicator (one of c(ube), o(ctahedron), i(cosahedron),\n//  t(etradron), or d(odecahedron), followed by an array of cuts.\n//  Each cut is a character normal indicator that is either f(ace),\n//  e(dge), or v(ertex), followed by a floating point value that gives\n//  the depth of the cut where 0 is the center and 1 is the outside\n//  border of the shape in that direction.\n\n//  This is a heavyweight class with lots of members and construction\n//  is slow.  Be gentle.\n\n//  Everything except a very few methods should be considered private.\n\nexport class PuzzleGeometry {\n   static eps:number = 1e-9 ;\n   static copyright = \"PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.\" ;\n   args:string = \"\" ;\n   rotations: Array<Quat> ;    // all members of the rotation group\n   baseplanerot: Array<Quat> ; // unique rotations of the baseplane\n   baseplanes: Array<Quat> ;   // planes, corresponding to faces\n   facenames: Array<any> ;     // face names\n   faceplanes: any ;           // face planes\n   edgenames: Array<any> ;     // edge names\n   vertexnames: Array<any> ;   // vertexnames\n   geonormals: Array<any> ;    // all geometric directions, with names and types\n   moveplanes: Array<Quat> ;   // the planes that split moves\n   moveplanesets: Array<any> ; // the move planes, in parallel sets\n   movesetorders: Array<any> ; // the order of rotations for each move set\n   movesetgeos: Array<any> ;   // geometric feature information for move sets\n   faces: Array<Array<Quat>> ; // all the stickers\n   basefacecount: number;      // number of base faces\n   stickersperface: number;    // number of stickers per face\n   cornerfaces: number;        // number of faces that meet at a corner\n   cubies: Array<any> ;        // the cubies\n   shortedge: number ;         // shortest edge\n   vertexdistance: number ;    // vertex distance\n   edgedistance: number ;      // edge distance\n   orbits: number ;            // count of cubie orbits\n   facetocubies: Array<any> ;  // map a face to a cubie index and offset\n   moverotations: Array<Array<Quat>> ; // move rotations\n   cubiekey: any ;             // cubie locator\n   cubiekeys: Array<string> ;  // cubie keys\n   facelisthash: any ;         // face list by key\n   cubiesetnames: Array<any> ; // cubie set names\n   cubieords: Array<number> ;  // the size of each orbit\n   cubiesetnums: Array<number> ;\n   cubieordnums: Array<number> ;\n   orbitoris: Array<number> ;  // the orientation size of each orbit\n   cubievaluemap: Array<number> ; // the map for identical cubies\n   cubiesetcubies: Array<Array<number>> ; // cubies in each cubie set\n   movesbyslice: Array<any> ;  // move as perms by slice\n   cmovesbyslice: Array<any>=[] ; // cmoves as perms by slice\n// options\n   verbose: number=1 ;         // verbosity (console.log)\n   allmoves: boolean = false ; // generate all slice moves in ksolve\n   outerblockmoves: boolean ;  // generate outer block moves\n   vertexmoves: boolean ;      // generate vertex moves\n   movelist: any ;             // move list to generate\n   parsedmovelist: any ;       // parsed move list\n   cornersets: boolean = true ; // include corner sets\n   centersets: boolean = true ; // include center sets\n   edgesets: boolean = true ;   // include edge sets\n   killorientation: boolean = false ; // eliminate any orientations\n   optimize: boolean = false ;  // optimize PermOri\n   scramble: number = 0 ;       // scramble?\n   ksolvemovenames: Array<string> ; // move names from ksolve\n   fixPiece: string = \"\" ;      // fix a piece?\n   fixedCubie: number = -1 ;    // fixed cubie, if any\n   svggrips: Array<any> ;       // grips from svg generation by svg coordinate\n//\n// This is a description of the nets and the external names we give each\n// face.  The names should be a set of prefix-free upper-case alphabetics\n// so\n// we can easily also name and distinguish vertices and edges, but we\n// may change this in the future.  The nets consist of a list of lists.\n// Each list gives the name of a face, and then the names of the\n// faces connected to that face (in the net) in clockwise order.\n// The length of each list should be one more than the number of\n// edges in the regular polygon for that face.  All polygons must\n// have the same number of edges.\n// The first two faces in the first list must describe a horizontal edge\n// that is at the bottom of a regular polygon.  The first two faces in\n// every subsequent list for a given polytope must describe a edge that\n// is directly connected in the net and has already been described (this\n// sets the location and orientation of the polygon for that face.\n// Any edge that is not directly connected in the net should be given\n// the empty string as the other face.  All faces do not need to have\n// a list starting with that face; just enough to describe the full\n// connectivity of the net.\n//\n   static defaultnets:any = {\n      4: // four faces: tetrahedron\n      [\n         [\"F\", \"D\", \"L\", \"R\"],\n      ],\n      6: // six faces: cube\n      [\n         [\"F\", \"D\", \"L\", \"U\", \"R\"],\n         [\"R\", \"F\", \"\", \"B\", \"\"],\n      ],\n      8: // eight faces: octahedron\n      [\n         [\"F\", \"D\", \"L\", \"R\"],\n         [\"D\", \"F\", \"N\", \"\"],\n         [\"N\", \"D\", \"\", \"B\"],\n         [\"B\", \"N\", \"U\", \"M\"],\n      ],\n      12: // twelve faces:  dodecahedron; U/F/R/F/BL/BR from megaminx\n      [\n         [\"U\", \"F\", \"\", \"\", \"\", \"\"],\n         [\"F\", \"U\", \"R\", \"C\", \"A\", \"L\"],\n         [\"R\", \"F\", \"\", \"\", \"E\", \"\"],\n         [\"E\", \"R\", \"\", \"BF\", \"\", \"\"],\n         [\"BF\", \"E\", \"BR\", \"BL\", \"I\", \"D\"],\n      ],\n      20: // twenty faces: icosahedron\n      [\n         [\"R\", \"C\", \"F\", \"E\"],\n         [\"F\", \"R\", \"L\", \"U\"],\n         [\"L\", \"F\", \"A\", \"\"],\n         [\"E\", \"R\", \"G\", \"I\"],\n         [\"I\", \"E\", \"S\", \"H\"],\n         [\"S\", \"I\", \"J\", \"B\"],\n         [\"B\", \"S\", \"K\", \"D\"],\n         [\"K\", \"B\", \"M\", \"O\"],\n         [\"O\", \"K\", \"P\", \"N\"],\n         [\"P\", \"O\", \"Q\", \"\"],\n      ],\n      } ;\n   net:any = [] ;\n   static defaultcolors:any = {\n// the colors should use the same naming convention as the nets, above.\n      4: { F: '#00ff00', D: '#ffff00', L: '#ff0000', R: '#0000ff', },\n      6: { U: '#ffffff', F: '#00ff00', R: '#ff0000',\n           D: '#ffff00', B: '#0000ff', L: '#ff8000', },\n      8: { U: '#e085b9', F: '#080d99', R: '#c1e35c', D: '#22955e',\n           B: '#9121ab', L: '#b27814', M: '#0d35ad', N: '#eb126b', },\n      12: { U: '#ffffff', F: '#ff0000', R: '#0000ff', C: '#ff66cc',\n            A: '#ffffd0', L: '#006633', E: '#99ff00', BF: '#ff6633',\n            BR: '#ffff00', BL: '#660099', I: '#3399ff', D: '#999999', },\n      20: { R: '#db69f0', C: '#178fde', F: '#23238b', E: '#9cc726',\n            L: '#2c212d', U: '#177fa7', A: '#e0de7f', G: '#2b57c0',\n            I: '#41126b', S: '#4b8c28', H: '#7c098d', J: '#7fe7b4',\n            B: '#85fb74', K: '#3f4bc3', D: '#0ff555', M: '#f1c2c8',\n            O: '#58d340', P: '#c514f2', N: '#14494e', Q: '#8b1be1', },\n   } ;\n   colors:any = [] ;\n   // the default precedence of the faces is given here.  This permits\n   // the orientations to be reasonably predictable.  There are tradeoffs;\n   // some face precedence orders do better things to the edge orientations\n   // than the corner orientations and some are the opposite.\n   static defaultfaceorders:any = {\n      4: [\"F\", \"D\", \"L\", \"R\"],\n      6: [\"U\", \"D\", \"F\", \"B\", \"L\", \"R\"],\n      8: [\"F\", \"B\", \"D\", \"U\", \"N\", \"L\", \"R\", \"M\"],\n      12: [\"L\", \"E\", \"F\", \"BF\", \"R\", \"I\",\n           \"U\", \"D\", \"BR\", \"A\", \"BL\", \"C\"],\n      20: [\"L\", \"S\", \"E\", \"O\", \"F\", \"B\", \"I\", \"P\", \"R\", \"K\",\n           \"U\", \"D\", \"J\", \"A\", \"Q\", \"H\", \"G\", \"N\", \"M\", \"C\"],\n   } ;\n   faceorder:any = [] ;\n   faceprecedence:Array<number> = [] ;\n   constructor(shape:string, cuts:Array<Array<string>>,\n               optionlist:Array<any>|undefined) {\n      if (optionlist != undefined) {\n         if (optionlist.length % 2 != 0)\n            throw \"Odd length in option list?\" ;\n         for (var i=0; i<optionlist.length; i += 2) {\n            if (optionlist[i] == \"verbose\")\n               this.verbose++ ;\n            else if (optionlist[i] == \"quiet\")\n               this.verbose = 0 ;\n            else if (optionlist[i] == \"allmoves\")\n               this.allmoves = optionlist[i+1] ;\n            else if (optionlist[i] == \"outerblockmoves\")\n               this.outerblockmoves = optionlist[i+1] ;\n            else if (optionlist[i] == \"vertexmoves\")\n               this.vertexmoves = optionlist[i+1] ;\n            else if (optionlist[i] == \"cornersets\")\n               this.cornersets = optionlist[i+1] ;\n            else if (optionlist[i] == \"centersets\")\n               this.centersets = optionlist[i+1] ;\n            else if (optionlist[i] == \"edgesets\")\n               this.edgesets = optionlist[i+1] ;\n            else if (optionlist[i] == \"movelist\")\n               this.movelist = optionlist[i+1] ;\n            else if (optionlist[i] == \"killorientation\")\n               this.killorientation = optionlist[i+1] ;\n            else if (optionlist[i] == \"optimize\")\n               this.optimize = optionlist[i+1] ;\n            else if (optionlist[i] == \"scramble\")\n               this.scramble = optionlist[i+1] ;\n            else if (optionlist[i] == \"fix\")\n               this.fixPiece = optionlist[i+1] ;\n            else\n               throw \"Bad option while processing option list \" + optionlist[i] ;\n         }\n      }\n      this.args = shape + \" \" + (cuts.map((_)=>_.join(\" \")).join(\" \")) ;\n      if (optionlist)\n         this.args += \" \" + optionlist.join(\" \") ;\n      if (this.verbose > 0)\n         console.log(this.header(\"# \")) ;\n      this.create(shape, cuts) ;\n   }\n   static findelement(a:Array<any>, p:Quat):number {\n   // find something in facenames, vertexnames, edgenames\n      for (var i=0; i<a.length; i++)\n         if (a[i][0].dist(p) < PuzzleGeometry.eps)\n            return i ;\n      throw \"Element not found\" ;\n   }\n   // split a geometrical element into face names.  The facenames must\n   // be prefix-free.\n   splitByFaceNames(s:string, facenames:Array<any>):Array<string> {\n      var r:Array<string> = [] ;\n      var at = 0 ;\n      while (at < s.length) {\n         var found = false ;\n         for (var i=0; i<facenames.length; i++) {\n            if (s.substr(at).startsWith(facenames[i][1])) {\n               r.push(facenames[i][1]) ;\n               at += facenames[i][1].length ;\n               found = true ;\n               break ;\n            }\n         }\n         if (!found)\n            throw(\"Could not split \" + s + \" into face names.\") ;\n      }\n      return r ;\n   }\n   create(shape:string, cuts:Array<any>):void {\n   // create the shape, doing all the essential geometry\n   // create only goes far enough to figure out how many stickers per\n   // face, and what the short edge is.  If the short edge is too short,\n   // we probably don't want to display or manipulate this one.  How\n   // short is too short is hard to say.\n      var that = this ;\n      this.moveplanes = [] ;\n      this.faces = [] ;\n      this.cubies = [] ;\n      var g = null ;\n      switch(shape) {\n         case 'c': g = PlatonicGenerator.cube() ; break ;\n         case 'o': g = PlatonicGenerator.octahedron() ; break ;\n         case 'i': g = PlatonicGenerator.icosahedron() ; break ;\n         case 't': g = PlatonicGenerator.tetrahedron() ; break ;\n         case 'd': g = PlatonicGenerator.dodecahedron() ; break ;\n         default: throw \"Bad shape argument: \" + shape ;\n      }\n      this.rotations = PlatonicGenerator.closure(g) ;\n      if (this.verbose) console.log(\"# Rotations: \" + this.rotations.length) ;\n      var baseplane = g[0] ;\n      this.baseplanerot = PlatonicGenerator.uniqueplanes(baseplane, this.rotations) ;\n      var baseplanes = this.baseplanerot.map(\n                       function(_){ return baseplane.rotateplane(_) }) ;\n      this.baseplanes = baseplanes ;\n      this.basefacecount = baseplanes.length ;\n      var net = PuzzleGeometry.defaultnets[baseplanes.length] ;\n      this.net = net ;\n      this.colors = PuzzleGeometry.defaultcolors[baseplanes.length] ;\n      this.faceorder = PuzzleGeometry.defaultfaceorders[baseplanes.length] ;\n      if (this.verbose) console.log(\"# Base planes: \" + baseplanes.length) ;\n      var baseface = PlatonicGenerator.getface(baseplanes) ;\n      if (this.verbose) console.log(\"# Face vertices: \" + baseface.length) ;\n      var facenormal = baseplanes[0].makenormal() ;\n      var edgenormal = baseface[0].sum(baseface[1]).makenormal() ;\n      var vertexnormal = baseface[0].makenormal() ;\n      var cutplanes = [] ;\n      for (var i=0; i<cuts.length; i++) {\n         var normal = null ;\n         switch (cuts[i][0]) {\n            case 'f': normal = facenormal ; break ;\n            case 'v': normal = vertexnormal ; break ;\n            case 'e': normal = edgenormal ; break ;\n            default: throw \"Bad cut argument: \" + cuts[i][0] ;\n         }\n         cutplanes.push(normal.makecut(cuts[i][1])) ;\n      }\n      var boundary = new Quat(1, facenormal.b, facenormal.c, facenormal.d) ;\n      if (this.verbose) console.log(\"# Boundary is \" + boundary) ;\n      var planerot = PlatonicGenerator.uniqueplanes(boundary, this.rotations) ;\n      var planes = planerot.map(function(_){return boundary.rotateplane(_)}) ;\n      var faces = [PlatonicGenerator.getface(planes)] ;\n//\n//   Determine names for edges, vertices, and planes.  Planes are defined\n//   by the plane normal/distance; edges are defined by the midpoint;\n//   vertices are defined by actual point.  In each case we define a name.\n//   Note that edges have two potential names, and corners have n where\n//   n planes meet at a vertex.  We arbitrarily choose the one that is\n//   alphabetically first (and we will probably want to change this).\n//\n      var facenames:Array<any> = [] ;\n      var faceplanes = [] ;\n      var vertexnames:Array<any> = [] ;\n      var edgenames:Array<any> = [] ;\n      var edgesperface = faces[0].length ;\n      function searchaddelement(a:Array<any>, p:Quat, name:any) {\n         for (var i=0; i<a.length; i++)\n            if (a[i][0].dist(p) < PuzzleGeometry.eps) {\n               a[i].push(name) ;\n               return ;\n            }\n         a.push([p, name]) ;\n      }\n      for (var i=0; i<this.baseplanerot.length; i++) {\n         var face = this.baseplanerot[i].rotateface(faces[0]) ;\n         for (var j=0; j<face.length; j++) {\n            var jj = (j + 1) % face.length ;\n            var midpoint = face[j].sum(face[jj]).smul(0.5) ;\n            searchaddelement(edgenames, midpoint, i) ;\n         }\n      }\n      var otherfaces = [] ;\n      for (var i=0; i<this.baseplanerot.length; i++) {\n         var face = this.baseplanerot[i].rotateface(faces[0]) ;\n         var facelist = [] ;\n         for (var j=0; j<face.length; j++) {\n            var jj = (j + 1) % face.length ;\n            var midpoint = face[j].sum(face[jj]).smul(0.5) ;\n            var el = edgenames[PuzzleGeometry.findelement(edgenames, midpoint)] ;\n            if (i == el[1])\n               facelist.push(el[2]) ;\n            else if (i == el[2]) \n               facelist.push(el[1]) ;\n            else\n               throw \"Could not find edge\" ;\n         }\n         otherfaces.push(facelist) ;\n      }\n      var facenametoindex:any = {} ;\n      var faceindextoname:any = [] ;\n      faceindextoname.push(net[0][0]) ;\n      facenametoindex[net[0][0]] = 0 ;\n      faceindextoname[otherfaces[0][0]] = net[0][1] ;\n      facenametoindex[net[0][1]] = otherfaces[0][0] ;\n      for (var i=0; i<net.length; i++) {\n         var f0 = net[i][0] ;\n         var fi = facenametoindex[f0] ;\n         if (fi == undefined)\n            throw \"Bad edge description; first edge not connected\" ;\n         var ii = -1 ;\n         for (var j=0; j<otherfaces[fi].length; j++) {\n            var fn2 = faceindextoname[otherfaces[fi][j]] ;\n            if (fn2 != undefined && fn2 == net[i][1]) {\n               ii = j ;\n               break ;\n            }\n         }\n         if (ii < 0)\n            throw \"First element of a net not known\" ;\n         for (var j=2; j<net[i].length; j++) {\n            if (net[i][j] == \"\")\n               continue ;\n            var of = otherfaces[fi][(j+ii-1)%edgesperface] ;\n            var fn2 = faceindextoname[of] ;\n            if (fn2 != undefined && fn2 != net[i][j])\n               throw \"Face mismatch in net\" ;\n            faceindextoname[of] = net[i][j] ;\n            facenametoindex[net[i][j]] = of ;\n         }\n      }\n      for (var i=0; i<faceindextoname.length; i++) {\n         var found = false ;\n         for (var j=0; j<this.faceorder.length; j++) {\n            if (faceindextoname[i] == this.faceorder[j]) {\n               this.faceprecedence[i] = j ;\n               found = true ;\n               break ;\n            }\n         }\n         if (!found)\n            throw \"Could not find face \" + faceindextoname[i] +\n                  \" in face order list \" + this.faceorder ;\n      }\n      for (var i=0; i<this.baseplanerot.length; i++) {\n         var face = this.baseplanerot[i].rotateface(faces[0]) ;\n         var faceplane = boundary.rotateplane(this.baseplanerot[i]) ;\n         var facename = faceindextoname[i] ;\n         facenames.push([face, facename]) ;\n         faceplanes.push([faceplane, facename]) ;\n      }\n      for (var i=0; i<this.baseplanerot.length; i++) {\n         var face = this.baseplanerot[i].rotateface(faces[0]) ;\n         var facename = faceindextoname[i] ;\n         for (var j=0; j<face.length; j++) {\n            var jj = (j + 1) % face.length ;\n            var midpoint = face[j].sum(face[jj]).smul(0.5) ;\n            var jjj = (j + 2) % face.length ;\n            var midpoint2 = face[jj].sum(face[jjj]).smul(0.5) ;\n            var e1 = PuzzleGeometry.findelement(edgenames, midpoint) ;\n            var e2 = PuzzleGeometry.findelement(edgenames, midpoint2) ;\n            searchaddelement(vertexnames, face[jj], [facename, e2, e1]) ;\n         }\n      }\n      // fix the edge names; use face precedence order\n      for (var i=0; i<edgenames.length; i++) {\n         if (edgenames[i].length != 3)\n            throw \"Bad length in edge names \" + edgenames[i] ;\n         var c1 = faceindextoname[edgenames[i][1]] ;\n         var c2 = faceindextoname[edgenames[i][2]] ;\n         if (this.faceprecedence[edgenames[i][1]] <\n             this.faceprecedence[edgenames[i][2]])\n            c1 = c1 + c2 ;\n         else\n            c1 = c2 + c1 ;\n         edgenames[i] = [edgenames[i][0], c1] ;\n      }\n      // fix the vertex names; clockwise rotations; low face first.\n      this.cornerfaces = vertexnames[0].length - 1 ;\n      for (var i=0; i<vertexnames.length; i++) {\n         if (vertexnames[i].length < 4)\n            throw \"Bad length in vertex names\" ;\n         var st = 1 ;\n         for (var j=2; j<vertexnames[i].length; j++) {\n            if (this.faceprecedence[facenametoindex[vertexnames[i][j][0]]] <\n                this.faceprecedence[facenametoindex[vertexnames[i][st][0]]])\n               st = j ;\n         }\n         var r = '' ;\n         for (var j=1; j<vertexnames[i].length; j++) {\n            r = r + vertexnames[i][st][0] ;\n            for (var k=1; k<vertexnames[i].length; k++)\n               if (vertexnames[i][st][2] == vertexnames[i][k][1]) {\n                  st = k ;\n                  break ;\n               }\n         }\n         vertexnames[i] = [vertexnames[i][0], r] ;\n      }\n      if (this.verbose > 1) {\n         console.log(\"Face precedence list: \" + this.faceorder.join(\" \")) ;\n         console.log(\"Face names: \" + facenames.map((_:any)=>_[1]).join(\" \")) ;\n         console.log(\"Edge names: \" + edgenames.map((_:any)=>_[1]).join(\" \")) ;\n         console.log(\"Vertex names: \" + vertexnames.map((_:any)=>_[1]).join(\" \")) ;\n      }\n      var geonormals = [] ;\n      for (var i=0; i<faceplanes.length; i++)\n         geonormals.push(\n                       [faceplanes[i][0].makenormal(), faceplanes[i][1], 'f']) ;\n      for (var i=0; i<edgenames.length; i++)\n         geonormals.push([edgenames[i][0].makenormal(), edgenames[i][1], 'e']) ;\n      for (var i=0; i<vertexnames.length; i++)\n         geonormals.push(\n                     [vertexnames[i][0].makenormal(), vertexnames[i][1], 'v']) ;\n      this.facenames = facenames ;\n      this.faceplanes = faceplanes ;\n      this.edgenames = edgenames ;\n      this.vertexnames = vertexnames ;\n      this.geonormals = geonormals ;\n      var zero = new Quat(0, 0, 0, 0) ;\n      this.edgedistance = faces[0][0].sum(faces[0][1]).smul(0.5).dist(zero) ;\n      this.vertexdistance = faces[0][0].dist(zero) ;\n      if (this.verbose)\n         console.log(\"# Distances: face \" + 1 + \" edge \" + this.edgedistance +\n                  \" vertex \" + this.vertexdistance) ;\n      // expand cutplanes by rotations.  We only work with one face here.\n      for (var c=0; c<cutplanes.length; c++) {\n         for (var i=0; i<this.rotations.length; i++) {\n            var q = cutplanes[c].rotateplane(this.rotations[i]) ;\n            var wasseen = false ;\n            for (var j=0; j<this.moveplanes.length; j++) {\n               if (q.sameplane(this.moveplanes[j])) {\n                  wasseen = true ;\n                  break ;\n               }\n            }\n            if (!wasseen) {\n               this.moveplanes.push(q) ;\n               faces = q.cutfaces(faces) ;\n            }\n         }\n      }\n      this.faces = faces ;\n      if (this.verbose) console.log(\"# Faces is now \" + faces.length) ;\n      this.stickersperface = faces.length ;\n      //  Find and report the shortest edge in any of the faces.  If this\n      //  is small the puzzle is probably not practical or displayable.\n      var shortedge = 1e99 ;\n      for (var i=0; i<faces.length; i++) {\n         for (var j=0; j<faces[i].length; j++) {\n            var k = (j + 1) % faces[i].length ;\n            var t = faces[i][j].dist(faces[i][k]) ;\n            if (t < shortedge)\n               shortedge = t ;\n         }\n      }\n      this.shortedge = shortedge ;\n      if (this.verbose) console.log(\"# Short edge is \" + shortedge) ;\n   }\n   keyface(face:Array<Quat>):string {\n   // take a face and figure out the sides of each move plane\n      var s = '' ;\n      for (var i=0; i<this.moveplanesets.length; i++) {\n         var t = 0 ;\n         for (var j=0; j<this.moveplanesets[i].length; j++)\n            if (this.moveplanesets[i][j].faceside(face) > 0)\n               t++ ;\n         s = s + ' ' + t ;\n      }\n      return s ;\n   }\n   findcubie(face:Array<Quat>):number {\n      return this.facetocubies[this.findface(face)][0] ;\n   }\n   findface(face:Array<Quat>):number {\n      var cm = Quat.centermassface(face) ;\n      var key = this.keyface(face) ;\n      for (var i=0; i<this.facelisthash[key].length; i++) {\n         var face2 = this.facelisthash[key][i] ;\n         if (Math.abs(cm.dist(\n                     Quat.centermassface(this.faces[face2]))) < PuzzleGeometry.eps)\n            return face2 ;\n      }\n      throw \"Could not find face.\" ;\n   }\n   project2d(facen:number, edgen:number, targvec:Array<Quat>):any {\n   // calculate geometry to map a particular edge of a particular\n   //  face to a given 2D vector.  The face is given as an index into the\n   //  facenames/baseplane arrays, and the edge is given as an offset into\n   //  the vertices.\n      var face = this.facenames[facen][0] ;\n      var edgen2 = (edgen + 1) % face.length ;\n      var plane = this.baseplanes[facen] ;\n      var x0 = face[edgen2].sub(face[edgen]) ;\n      var olen = x0.len() ;\n      x0 = x0.normalize() ;\n      var y0 = x0.cross(plane).normalize() ;\n      var delta = targvec[1].sub(targvec[0]) ;\n      var len = delta.len() / olen ;\n      delta = delta.normalize() ;\n      var cosr = delta.b ;\n      var sinr = delta.c ;\n      var x1 = x0.smul(cosr).sub(y0.smul(sinr)).smul(len) ;\n      var y1 = y0.smul(cosr).sum(x0.smul(sinr)).smul(len) ;\n      var off = new Quat(0, targvec[0].b - x1.dot(face[edgen]),\n                        targvec[0].c - y1.dot(face[edgen]), 0) ;\n      return [x1, y1, off] ;\n   }\n   allstickers():void {\n   // next step is to calculate all the stickers and orbits\n   // We do enough work here to display the cube on the screen.\n   // take our newly split base face and expand it by the rotation matrix.\n   // this generates our full set of \"stickers\".\n      this.faces = Quat.expandfaces(this.baseplanerot, this.faces) ;\n      if (this.verbose) console.log(\"# Total stickers is now \" + this.faces.length) ;\n      // Split moveplanes into a list of parallel planes.\n      var moveplanesets = [] ;\n      for (var i=0; i<this.moveplanes.length; i++) {\n         var wasseen = false ;\n         var q = this.moveplanes[i] ;\n         var qnormal = q.makenormal() ;\n         for (var j=0; j<moveplanesets.length; j++) {\n            if (qnormal.sameplane(moveplanesets[j][0].makenormal())) {\n               moveplanesets[j].push(q) ;\n               wasseen = true ;\n               break ;\n            }\n         }\n         if (!wasseen)\n            moveplanesets.push([q]) ;\n      }\n      // make the normals all face the same way in each set.\n      for (var i=0; i<moveplanesets.length; i++) {\n         var a:Array<Quat> = moveplanesets[i].map(\n                              function(_) { return _.normalizeplane()}) ;\n         var goodnormal = a[0].makenormal() ;\n         for (var j=0; j<a.length; j++)\n            if (a[j].makenormal().dist(goodnormal) > PuzzleGeometry.eps)\n               a[j] = a[j].smul(-1) ;\n         a.sort(function(a,b){return a.a-b.a;}) ;\n         moveplanesets[i] = a ;\n      }\n      this.moveplanesets = moveplanesets ;\n      var sizes = moveplanesets.map(function(_){return _.length}) ;\n      if (this.verbose) console.log(\"# Move plane sets: \" + sizes) ;\n      // for each of the move planes, find the rotations that are relevant\n      var moverotations:Array<Array<Quat>> = [] ;\n      for (var i=0; i<moveplanesets.length; i++)\n         moverotations.push([]) ;\n      for (var i=0; i<this.rotations.length; i++) {\n         var q:Quat = this.rotations[i] ;\n         if (Math.abs(Math.abs(q.a)-1) < PuzzleGeometry.eps)\n            continue ;\n         var qnormal = q.makenormal() ;\n         for (var j=0; j<moveplanesets.length; j++)\n            if (qnormal.sameplane(moveplanesets[j][0].makenormal())) {\n               moverotations[j].push(q) ;\n               break ;\n            }\n      }\n      this.moverotations = moverotations ;\n      //  Sort the rotations by the angle of rotation.  A bit tricky because\n      //  while the norms should be the same, they need not be.  So we start\n      //  by making the norms the same, and then sorting.\n      for (var i=0; i<moverotations.length; i++) {\n         var a = moverotations[i] ;\n         var goodnormal = a[0].makenormal() ;\n         for (var j=0; j<a.length; j++)\n            if (goodnormal.dist(a[j].makenormal()) > PuzzleGeometry.eps)\n               a[j] = a[j].smul(-1) ;\n         a.sort(function(a,b){return a.angle()-b.angle()}) ;\n         if (moverotations[i][0].dot(moveplanesets[i][0]) < 0)\n            a.reverse() ;\n      }\n      var sizes = moverotations.map(function(_){return 1+_.length}) ;\n      this.movesetorders = sizes ;\n      var movesetgeos = [] ;\n      for (var i=0; i<moveplanesets.length; i++) {\n         var p0 = moveplanesets[i][0].makenormal() ;\n         var neg = null ;\n         var pos = null ;\n         for (var j=0; j<this.geonormals.length; j++) {\n            var d = p0.dot(this.geonormals[j][0]) ;\n            if (Math.abs(d-1) < PuzzleGeometry.eps) {\n               pos = [this.geonormals[j][1], this.geonormals[j][2]] ;\n            } else if (Math.abs(d+1) < PuzzleGeometry.eps) {\n               neg = [this.geonormals[j][1], this.geonormals[j][2]] ;\n            }\n         }\n         if (pos == null || neg == null)\n            throw \"Saw positive or negative sides as null\" ;\n         movesetgeos.push([pos[0], pos[1], neg[0], neg[1],\n                          1+ moveplanesets[i].length]) ;\n      }\n      this.movesetgeos = movesetgeos ;\n      //  Cubies are split by move plane sets.  For each cubie we can\n      //  average its points to find a point on the interior of that\n      //  cubie.  We can then check that point against all the move\n      //  planes and from that derive a coordinate for the cubie.\n      //  This also works for faces; no face should ever lie on a move\n      //  plane.  This allows us to take a set of stickers and break\n      //  them up into cubie sets.\n      var cubiehash:any = {} ;\n      var facelisthash:any = {} ;\n      var cubiekey:any = {} ;\n      var cubiekeys = [] ;\n      var cubies:Array<Array<Array<Quat>>> = [] ;\n      var faces = this.faces ;\n      for (var i=0; i<faces.length; i++) {\n         var face = faces[i] ;\n         var s = this.keyface(face) ;\n         if (!cubiehash[s]) {\n            cubiekey[s] = cubies.length ;\n            cubiekeys.push(s) ;\n            cubiehash[s] = [] ;\n            facelisthash[s] = [] ;\n            cubies.push(cubiehash[s]) ;\n         }\n         facelisthash[s].push(i) ;\n         cubiehash[s].push(face) ;\n         //  If we find a core cubie, split it up into multiple cubies,\n         //  because ksolve doesn't handle orientations that are not\n         //  cyclic, and the rotation group of the core is not cyclic.\n         if (facelisthash[s].length == this.basefacecount) {\n            if (this.verbose) console.log(\"# Splitting core.\") ;\n            for (var suff=0; suff<this.basefacecount; suff++) {\n               var s2 = s + \" \" + suff ;\n               facelisthash[s2] = [facelisthash[s][suff]] ;\n               cubiehash[s2] = [cubiehash[s][suff]] ;\n               cubiekeys.push(s2) ;\n               cubiekey[s2] = cubies.length ;\n               cubies.push(cubiehash[s2]) ;\n            }\n            cubiehash[s] = [] ;\n            cubies[cubiekey[s]] = [] ;\n         }\n      }\n      this.cubiekey = cubiekey ;\n      this.facelisthash = facelisthash ;\n      this.cubiekeys = cubiekeys ;\n      if (this.verbose) console.log(\"# Cubies: \" + Object.keys(cubiehash).length) ;\n      var that = this ;\n      function getfaceindex(facenum:number):number {\n         var divid = that.stickersperface ;\n         return Math.floor(facenum/divid) ;\n      }\n      //  Sort the faces around each corner so they are clockwise.  Only\n      //  relevant for cubies that actually are corners (three or more\n      //  faces).  In general cubies might have many faces; for icosohedrons\n      //  there are five faces on the corner cubies.\n      this.cubies = cubies ;\n      for (var k=0; k<cubies.length; k++) {\n         var cubie = cubies[k] ;\n         if (cubie.length < 2)\n            continue ;\n         if (cubie.length == this.basefacecount) // looks like core?  don't sort\n            continue ;\n         if (cubie.length > 5)\n            throw \"Bad math; too many faces on this cubie \" + cubie.length ;\n         var s = this.keyface(cubie[0]) ;\n         var facelist = facelisthash[s] ;\n         var cm = cubie.map(\n                       function(_){return Quat.centermassface(_)}) ;\n         var cmall = Quat.centermassface(cm) ;\n         for (var looplimit=0; cubie.length > 2; looplimit++) {\n            var changed = false ;\n            for (var i=0; i<cubie.length; i++) {\n               var j = (i + 1) % cubie.length ;\n               var ttt = cmall.dot(cm[i].cross(cm[j])) ;\n               if (cmall.dot(cm[i].cross(cm[j])) < 0) {\n                  var t = cubie[i] ;\n                  cubie[i] = cubie[j] ;\n                  cubie[j] = t ;\n                  var u = cm[i] ;\n                  cm[i] = cm[j] ;\n                  cm[j] = u ;\n                  var v = facelist[i] ;\n                  facelist[i] = facelist[j] ;\n                  facelist[j] = v ;\n                  changed = true ;\n               }\n            }\n            if (!changed)\n               break ;\n            if (looplimit > 1000)\n               throw(\"Bad epsilon math; too close to border\") ;\n         }\n         var mini = 0 ;\n         var minf = this.findface(cubie[mini]) ;\n         for (var i=1; i<cubie.length; i++) {\n            var temp = this.findface(cubie[i]) ;\n            if (this.faceprecedence[getfaceindex(temp)] <\n                this.faceprecedence[getfaceindex(minf)]) {\n               mini = i ;\n               minf = temp ;\n            }\n         }\n         if (mini != 0) {\n            var ocubie = cubie.slice() ;\n            var ofacelist = facelist.slice() ;\n            for (var i=0; i<cubie.length; i++) {\n               cubie[i] = ocubie[(mini+i)%cubie.length] ;\n               facelist[i] = ofacelist[(mini+i)%cubie.length] ;\n            }\n         }\n      }\n      //  Build an array that takes each face to a cubie ordinal and a\n      //  face number.\n      var facetocubies = [] ;\n      for (var i=0; i<cubies.length; i++) {\n         var facelist = facelisthash[cubiekeys[i]] ;\n         for (var j=0; j<facelist.length; j++) {\n            facetocubies[facelist[j]] = [i, j] ;\n         }\n      }\n      this.facetocubies = facetocubies ;\n      //  Calculate the orbits of each cubie.  Assumes we do all moves.\n      //  Also calculates which cubies are identical.\n      var typenames = ['?', 'CENTER', 'EDGE', 'CORNER', 'C4RNER', 'C5RNER'] ;\n      var cubiesetnames = [] ;\n      var cubietypecounts = [0, 0, 0, 0, 0, 0] ;\n      var orbitoris = [] ;\n      var seen = [] ;\n      var cubiesetnum = 0 ;\n      var cubiesetnums = [] ;\n      var cubieordnums = [] ;\n      var cubieords = [] ;\n      var cubiesetnumhash = {} ;\n      var cubievaluemap = [] ;\n      // Later we will make this smarter to use a get color for face function\n      // so we support puzzles with multiple faces the same color\n      function getcolorkey(cubienum:number):string {\n         return cubies[cubienum].map(\n                  (_)=> getfaceindex(that.findface(_))).join(\" \") ;\n      }\n      var cubiesetcubies:any = [] ;\n      for (var i=0; i<cubies.length; i++) {\n         if (seen[i])\n            continue ;\n         var cubie = cubies[i] ;\n         if (cubie.length == 0)\n            continue ;\n         var cubiekeymap:any = {} ;\n         var cubievalueid = 0 ;\n         cubieords.push(0) ;\n         cubiesetcubies.push([]) ;\n         var facecnt = cubie.length ;\n         var typectr = cubietypecounts[facecnt]++ ;\n         var typename = typenames[facecnt] ;\n         if (typename == undefined || facecnt == this.basefacecount)\n            typename = \"CORE\" ;\n         typename = typename + (typectr == 0 ? '' : (typectr+1)) ;\n         cubiesetnames[cubiesetnum] = typename ;\n         orbitoris[cubiesetnum] = facecnt ;\n         var queue = [i] ;\n         var qg = 0 ;\n         seen[i] = true ;\n         while (qg < queue.length) {\n            var cind = queue[qg++] ;\n            var cubiecolorkey = getcolorkey(cind) ;\n            if (cubie.length > 1 || cubiekeymap[cubiecolorkey] == undefined)\n               cubiekeymap[cubiecolorkey] = cubievalueid++ ;\n            cubievaluemap[cind] = cubiekeymap[cubiecolorkey] ;\n            cubiesetnums[cind] = cubiesetnum ;\n            cubiesetcubies[cubiesetnum].push(cind) ;\n            cubieordnums[cind] = cubieords[cubiesetnum]++ ;\n            for (var j=0; j<moverotations.length; j++) {\n               var tq = this.findcubie(moverotations[j][0].rotateface(cubies[cind][0])) ;\n               if (!seen[tq]) {\n                  queue.push(tq) ;\n                  seen[tq] = true ;\n               }\n            }\n         }\n         cubiesetnum++ ;\n      }\n      this.orbits = cubieords.length ;\n      this.cubiesetnums = cubiesetnums ;\n      this.cubieordnums = cubieordnums ;\n      this.cubiesetnames = cubiesetnames ;\n      this.cubieords = cubieords ;\n      this.orbitoris = orbitoris ;\n      this.cubievaluemap = cubievaluemap ;\n      this.cubiesetcubies = cubiesetcubies ;\n      // if we fix a cubie, find a cubie to fix\n      if (this.fixPiece != \"\") {\n         for (var i=0; i<cubies.length; i++)\n            if ((this.fixPiece == 'v' && cubies[i].length > 2) ||\n                (this.fixPiece == 'e' && cubies[i].length == 2) ||\n                (this.fixPiece == 'f' && cubies[i].length == 1)) {\n               this.fixedCubie = i ;\n               break ;\n            }\n         if (this.fixedCubie < 0)\n            throw \"Could not find a cubie of type \" + this.fixPiece + \" to fix.\" ;\n      }\n      // show the orbits\n      if (this.verbose) console.log(\"# Cubie orbit sizes \" + cubieords) ;\n   }\n   spinmatch(a:string, b:string):boolean {\n      // are these the same rotationally?\n      if (a == b)\n         return true ;\n      if (a.length != b.length)\n         return false ;\n      try {\n         var e1 = this.splitByFaceNames(a, this.facenames) ;\n         var e2 = this.splitByFaceNames(b, this.facenames) ;\n         if (e1.length != e2.length)\n            return false ;\n         for (var i=0; i<e1.length; i++)\n            if (e1[i] == e2[0]) {\n               for (var j=0; j<e2.length; j++)\n                  if (e1[(i+j)%e1.length] != e2[j])\n                     return false ;\n               return true ;\n            }\n         return false ;\n      } catch (e) {\n         return false ;\n      }\n   }\n   parsemove(mv:string):any { // parse a move from the command line\n      var re = RegExp(\"^(([0-9]+)-)?([0-9]+)?([A-Za-z]+)([-'0-9]+)?$\") ;\n      var p = mv.match(re) ;\n      if (p == null)\n         throw \"Bad move passed \" + mv ;\n      var grip = p[4] ;\n      var geo = undefined ;\n      var msi = -1 ;\n      var upperCaseGrip = grip.toUpperCase() ;\n      var firstgrip = false ;\n      for (var i=0; i<this.movesetgeos.length; i++) {\n         var g = this.movesetgeos[i] ;\n         if (this.spinmatch(g[0], upperCaseGrip)) {\n            firstgrip = true ;\n            geo = g ;\n            msi = i ;\n         }\n         if (this.spinmatch(g[2], upperCaseGrip)) {\n            firstgrip = false ;\n            geo = g ;\n            msi = i ;\n         }\n      }\n      var loslice = 1 ;\n      var hislice = 1 ;\n      if (upperCaseGrip != grip) {\n         hislice = 2 ;\n      }\n      if (geo == undefined)\n         throw \"Bad grip in move \" + mv ;\n      if (p[2] != undefined) {\n         if (p[3] == undefined)\n            throw \"Missing second number in range\" ;\n         loslice = parseInt(p[2]) ;\n      }\n      if (p[3] != undefined) {\n         if (p[2] == undefined) {\n            hislice = parseInt(p[3]) ;\n            if (upperCaseGrip == grip)\n               loslice = hislice ;\n            else\n               loslice = 1 ;\n         } else {\n            hislice = parseInt(p[3]) ;\n         }\n      }\n      loslice-- ;\n      hislice-- ;\n      if (loslice < 0 || loslice > this.moveplanesets[msi].length ||\n          hislice < 0 || hislice > this.moveplanesets[msi].length)\n         throw \"Bad slice spec \" + loslice + \" \" + hislice ;\n      var amountstr = \"1\" ;\n      var amount = 1 ;\n      if (p[5] != undefined) {\n         amountstr = p[5] ;\n         if (amountstr[0] == \"'\")\n            amountstr = \"-\" + amountstr.substring(1) ;\n         if (amountstr[0] == '+')\n            amountstr = amountstr.substring(1) ;\n         else if (amountstr[0] == '-') {\n            if (amountstr == \"-\")\n               amountstr = \"-1\" ;\n         }\n         amount = parseInt(amountstr) ;\n      }\n      var r = [mv, msi, loslice, hislice, firstgrip, amount] ;\n      return r ;\n   }\n   genperms():void { // generate permutations for moves\n      if (this.cmovesbyslice.length > 0) // did this already?\n         return ;\n      var mvcnt = 0 ;\n      var movesbyslice = [] ;\n      var cmovesbyslice = [] ;\n      for (var k=0; k<this.moveplanesets.length; k++) {\n         var moveplaneset = this.moveplanesets[k] ;\n         var slicenum = [] ;\n         var slicecnts = [] ;\n         for (var i=0; i<this.faces.length; i++) {\n            var face = this.faces[i] ;\n            var t = 0 ;\n            for (var j=0; j<moveplaneset.length; j++) {\n               if (moveplaneset[j].faceside(face) < 0)\n                  t++ ;\n            }\n            slicenum.push(t) ;\n            while (slicecnts.length <= t)\n               slicecnts.push(0) ;\n            slicecnts[t]++ ;\n         }\n         var axismoves = [] ;\n         var axiscmoves = [] ;\n         for (var sc=0; sc<slicecnts.length; sc++) {\n            var mv = '' ;\n            var slicemoves = [] ;\n            var slicecmoves = [] ;\n            var cubiedone = [] ;\n            for (var i=0; i<this.faces.length; i++) {\n               if (slicenum[i] != sc)\n                  continue ;\n               var a = [i] ;\n               var b = this.facetocubies[i].slice() ;\n               var face = this.faces[i] ;\n               var fi2 = i ;\n               while (true) {\n                  slicenum[fi2] = -1 ;\n                  var face2 = this.moverotations[k][0].rotateface(face) ;\n                  fi2 = this.findface(face2) ;\n                  if (slicenum[fi2] < 0)\n                     break ;\n                  if (slicenum[fi2] != sc)\n                     throw \"Bad movement?\" ;\n                  a.push(fi2) ;\n                  var c = this.facetocubies[fi2] ;\n                  b.push(c[0], c[1]) ;\n                  face = face2 ;\n               }\n               if (a.length > 1)\n                  slicemoves.push(a) ;\n               if (b.length > 2 && !cubiedone[b[0]])\n                  slicecmoves.push(b) ;\n               for (var j=0; j<b.length; j += 2)\n                  cubiedone[b[j]] = true ;\n            }\n            axismoves.push(slicemoves) ;\n            axiscmoves.push(slicecmoves) ;\n         }\n         movesbyslice.push(axismoves) ;\n         cmovesbyslice.push(axiscmoves) ;\n      }\n      this.movesbyslice = movesbyslice ;\n      this.cmovesbyslice = cmovesbyslice ;\n      if (this.movelist != undefined) {\n         var parsedmovelist:Array<any> = [] ;\n         // make sure the movelist makes sense based on the geos.\n         for (var i=0; i<this.movelist.length; i++)\n            parsedmovelist.push(this.parsemove(this.movelist[i])) ;\n         this.parsedmovelist = parsedmovelist ;\n      }\n   }\n   getfaces():Array<Array<Array<number>>> { // get the faces for 3d.\n      return this.faces.map(\n              function(_){return _.map(function(_){return [_.b,_.c,_.d]})}) ;\n   }\n   getboundarygeometry():any { // get the boundary geometry\n      return {\n         baseplanes: this.baseplanes,\n         facenames: this.facenames,\n         faceplanes: this.faceplanes,\n         vertexnames: this.vertexnames,\n         edgenames: this.edgenames,\n         geonormals: this.geonormals,\n      } ;\n   }\n   getmovesets(k:number):any {\n      // get the move sets we support based on slices\n      // for even values we omit the middle \"slice\".  This isn't perfect\n      // but it is what we do for now.\n      // if there was a move list specified, pull values from that\n      var slices = this.moveplanesets[k].length ;\n      if (slices > 30)\n         throw \"Too many slices for getmovesets bitmasks\" ;\n      var r = [] ;\n      if (this.parsedmovelist != undefined) {\n         for (var i=0; i<this.parsedmovelist.length; i++) {\n            var parsedmove = this.parsedmovelist[i] ;\n            if (parsedmove[1] != k)\n               continue ;\n            if (parsedmove[4]) {\n               r.push((2<<parsedmove[3])-(1<<parsedmove[2])) ;\n            } else {\n               r.push((2<<(slices-parsedmove[2]))-(1<<(slices-parsedmove[3]))) ;\n            }\n            r.push(parsedmove[5]) ;\n         }\n      } else if (this.vertexmoves && !this.allmoves) {\n         var msg = this.movesetgeos[k] ;\n         if (msg[1] != msg[3]) {\n            for (var i=0; i<slices; i++) {\n               if (msg[1] != 'v') {\n                  if (this.outerblockmoves)\n                     r.push((2 << slices) - (2 << i)) ;\n                  else\n                     r.push(2<<i) ;\n                  r.push(1) ;\n               } else {\n                  if (this.outerblockmoves)\n                     r.push((2<<i)-1) ;\n                  else\n                     r.push(1<<i) ;\n                  r.push(1) ;\n               }\n            }\n         }\n      } else {\n         for (var i=0; i<=slices; i++) {\n            if (!this.allmoves && i + i == slices)\n               continue ;\n            if (this.outerblockmoves) {\n               if (i + i > slices)\n                  r.push((2 << slices) - (1 << i)) ;\n               else\n                  r.push((2<<i)-1) ;\n            } else\n               r.push(1<<i) ;\n            r.push(1) ;\n         }\n      }\n      if (this.fixedCubie >= 0) {\n         var dep = 1 << +this.cubiekeys[this.fixedCubie].trim().split(\" \")[k] ;\n         var newr = [] ;\n         for (var i=0; i<r.length; i += 2) {\n            var o = r[i] ;\n            if (o & dep)\n               o = (2 << slices) - 1 - o ;\n            var found = false ;\n            for (var j=0; j<newr.length; j += 2)\n               if (newr[j] == o && newr[j+1] == r[i+1]) {\n                  found = true ;\n                  break ;\n               }\n            if (!found) {\n               newr.push(o) ;\n               newr.push(r[i+1]) ;\n            }\n         }\n         r = newr ;\n      }\n      return r ;\n   }\n   skipbyori(cubie:number):boolean {\n      var ori = this.cubies[cubie].length ;\n      return ((ori == 1 && !this.centersets) ||\n              (ori == 2 && !this.edgesets) ||\n              (ori > 2 && !this.cornersets)) ;\n   }\n   skipcubie(set:Array<number>):boolean {\n      if (set.length == 0)\n         return true ;\n      var fi = set[0] ;\n      return this.skipbyori(fi) ;\n   }\n   skipset(set:Array<number>):boolean {\n      if (set.length == 0)\n         return true ;\n      var fi = set[0] ;\n      return this.skipbyori(this.facetocubies[fi][0]) ;\n   }\n   header(comment:string):string {\n      return comment + PuzzleGeometry.copyright + \"\\n\" +\n             comment + this.args + \"\\n\" ;\n   }\n   writegap():string { // write out a gap set of generators\n      var os = this.getOrbitsDef(false) ;\n      var r = [] ;\n      var mvs = [] ;\n      for (var i=0; i<os.moveops.length; i++) {\n         var movename = \"M_\" + os.movenames[i] ;\n         // gap doesn't like angle brackets in IDs\n         mvs.push(movename) ;\n         r.push(movename+\":=\"+os.moveops[i].toPerm().toGap()+\";\") ;\n      }\n      r.push(\"Gen:=[\") ;\n      r.push(mvs.join(\",\")) ;\n      r.push(\"];\") ;\n      var ip = os.solved.identicalPieces() ;\n      r.push(\"ip:=[\"+ip.map((_)=>\"[\"+_.map((_)=>_+1).join(\",\")+\"]\").\n                                                        join(\",\")+\"];\") ;\n      r.push(\"\") ;\n      return this.header(\"# \") + r.join(\"\\n\") ;\n   }\n   getmovename(geo:any, bits:number, slices:number):any {\n   // generate a move name based on bits, slice, and geo\n   // if the move name is from the opposite face, say so.\n   // find the face that's turned.\n      var nbits = 0 ;\n      var inverted = false ;\n      for (var i=0; i<=slices; i++)\n         if ((bits >> i) & 1)\n            nbits |= 1<<(slices-i) ;\n      if (nbits < bits) { // flip if most of the move is on the other side\n         geo = [geo[2], geo[3], geo[0], geo[1]] ;\n         bits = nbits ;\n         inverted = true ;\n      }\n      var movenameFamily = geo[0];\n      var movenamePrefix = \"\";\n      var hibit = 0 ;\n      while (bits >> (1 + hibit))\n         hibit++ ;\n      if (bits == (1 << hibit)) {\n         if (hibit > 0)\n            movenamePrefix = String(hibit + 1) ;\n      } else if (bits == ((2 << hibit) - 1)) {\n         movenameFamily = movenameFamily.toLowerCase() ;\n         if (hibit > 1)\n            movenamePrefix = String(hibit + 1) ;\n      } else {\n         movenamePrefix = \"_\" + bits + \"_\" ;\n//       throw \"We only support slice and outer block moves right now. \" + bits ;\n      }\n      return [movenamePrefix + movenameFamily, inverted] ;\n   }\n   writeksolve(name:string, fortwisty:boolean):string {\n      if (name == null)\n         name = \"PuzzleGeometryPuzzle\" ;\n      var od = this.getOrbitsDef(fortwisty) ;\n      if (fortwisty)\n         return od.toKsolve(name, fortwisty).join(\"\\n\") ;\n      else\n         return this.header(\"# \") + od.toKsolve(name, fortwisty).join(\"\\n\") ;\n   }\n   getOrbitsDef(fortwisty:boolean):OrbitsDef {\n      // generate a representation of the puzzle\n      var setmoves = [] ;\n      var setnames:Array<string> = [] ;\n      var setdefs:Array<OrbitDef> = [] ;\n      for (var k=0; k<this.moveplanesets.length; k++) {\n         var moveplaneset = this.moveplanesets[k] ;\n         var slices = moveplaneset.length ;\n         var moveset = this.getmovesets(k) ;\n         // check there's no redundancy in moveset.\n         for (var i=0; i<moveset.length; i += 2)\n            for (var j=0; j<i; j += 2)\n               if (moveset[i] == moveset[j] && moveset[i+1] == moveset[j+1])\n                  throw \"Redundant moves in moveset.\" ;\n         var allbits = 0 ;\n         for (var i=0; i<moveset.length; i += 2)\n            allbits |= moveset[i] ;\n         var axiscmoves = this.cmovesbyslice[k] ;\n         for (var i=0; i<axiscmoves.length; i++) {\n            if (((allbits >> i) & 1) == 0)\n               continue ;\n            var slicecmoves = axiscmoves[i] ;\n            for (var j=0; j<slicecmoves.length; j++) {\n               if (this.skipcubie(slicecmoves[j]))\n                  continue ;\n               var ind = this.cubiesetnums[slicecmoves[j][0]] ;\n               if (!setmoves[ind])\n                  setmoves[ind] = 1 ;\n               else\n                  setmoves[ind]++ ;\n            }\n         }\n      }\n      for (var i=0; i<this.cubiesetnames.length; i++) {\n         if (!setmoves[i])\n            continue ;\n         setnames.push(this.cubiesetnames[i]) ;\n         setdefs.push(new OrbitDef(this.cubieords[i],\n                              this.killorientation ? 1 : this.orbitoris[i])) ;\n      }\n      var solved:Array<Orbit> = [] ;\n      for (var i=0; i<this.cubiesetnames.length; i++) {\n         if (!setmoves[i])\n            continue ;\n         var p = [] ;\n         var o = [] ;\n         for (var j=0; j<this.cubieords[i]; j++) {\n            if (fortwisty)\n               p.push(j) ;\n            else {\n               var cubie = this.cubiesetcubies[i][j] ;\n               p.push(this.cubievaluemap[cubie]) ;\n            }\n            o.push(0) ;\n         }\n         solved.push(new Orbit(p, o, \n                             this.killorientation ? 1 : this.orbitoris[i])) ;\n      }\n      var movenames:Array<string> = [] ;\n      var moves:Array<Transformation> = [] ;\n      for (var k=0; k<this.moveplanesets.length; k++) {\n         var moveplaneset = this.moveplanesets[k] ;\n         var slices = moveplaneset.length ;\n         var moveset = this.getmovesets(k) ;\n         var movesetgeo = this.movesetgeos[k] ;\n         for (var i=0; i<moveset.length; i += 2) {\n            var movebits = moveset[i] ;\n            var mna = this.getmovename(movesetgeo, movebits, slices) ;\n            var movename = mna[0] ;\n            var inverted = mna[1] ;\n            movenames.push(movename) ;\n            var moveorbits:Array<Orbit> = [] ;\n            var perms = [] ;\n            var oris = [] ;\n            for (var ii=0; ii<this.cubiesetnames.length; ii++) {\n               var p = [] ;\n               for (var kk=0; kk<this.cubieords[ii]; kk++)\n                  p.push(kk) ;\n               perms.push(p) ;\n               var o = [] ;\n               for (var kk=0; kk<this.cubieords[ii]; kk++)\n                  o.push(0) ;\n               oris.push(o) ;\n            }\n            var axiscmoves = this.cmovesbyslice[k] ;\n            for (var m=0; m<axiscmoves.length; m++) {\n               if (((movebits >> m) & 1) == 0)\n                  continue ;\n               var slicecmoves = axiscmoves[m] ;\n               for (var j=0; j<slicecmoves.length; j++) {\n                  var mperm = slicecmoves[j].slice() ;\n                  var setnum = this.cubiesetnums[mperm[0]] ;\n                  for (var ii=0; ii<mperm.length; ii += 2)\n                     mperm[ii] = this.cubieordnums[mperm[ii]] ;\n                  var inc = 2 ;\n                  var oinc = 3 ;\n                  if (inverted) {\n                     inc = mperm.length - 2 ;\n                     oinc = mperm.length - 1 ;\n                  }\n                  for (var ii=0; ii<mperm.length; ii += 2) {\n                     perms[setnum][mperm[(ii+inc)%mperm.length]] = mperm[ii] ;\n                     if (this.killorientation)\n                        oris[setnum][mperm[ii]] = 0 ;\n                     else\n                        oris[setnum][mperm[ii]] =\n                            (mperm[(ii+oinc)%mperm.length] -\n                             mperm[(ii+1)%mperm.length] +\n                             this.orbitoris[setnum]) % this.orbitoris[setnum] ;\n                  }\n               }\n            }\n            for (var ii=0; ii<this.cubiesetnames.length; ii++) {\n               if (!setmoves[ii])\n                  continue ;\n               var no = new Array<number>(oris[ii].length) ;\n               // convert ksolve oris to our internal ori rep\n               for (var jj=0; jj<perms[ii].length; jj++)\n                  no[jj] = oris[ii][perms[ii][jj]] ;\n               moveorbits.push(new Orbit(perms[ii], no,\n                            this.killorientation ? 1 : this.orbitoris[ii])) ;\n            }\n            var mv = new Transformation(moveorbits) ;\n            if (moveset[i+1] != 1)\n               mv = mv.mulScalar(moveset[i+1]) ;\n            moves.push(mv) ;\n         }\n      }\n      this.ksolvemovenames = movenames ; // hack!\n      var r = new OrbitsDef(setnames, setdefs, new VisibleState(solved),\n                           movenames, moves) ;\n      if (this.optimize)\n         r = r.optimize() ;\n      if (this.scramble != 0)\n         r.scramble(this.scramble) ;\n      return r ;\n   }\n   getMovesAsPerms():Array<Perm> {\n      return this.getOrbitsDef(false).moveops.\n                                        map((_:Transformation)=>_.toPerm()) ;\n   }\n   showcanon(disp:(s:string)=>void):void {\n      // show information for canonical move derivation\n      showcanon(this.getOrbitsDef(false),disp) ;\n   }\n   getsolved():Perm { // get a solved position\n      var r = [] ;\n      for (var i=0; i<this.basefacecount; i++) {\n         for (var j=0; j<this.stickersperface; j++) {\n            r.push(i) ;\n         }\n      }\n      return new Perm(r) ;\n   }\n   static getpuzzles():Array<string> {\n   // get some simple definitions of basic puzzles\n      return [\n         \"c f 0\", \"2x2x2\",\n         \"c f 0.333333333333333\", \"3x3x3\",\n         \"c f 0.5 f 0\", \"4x4x4\",\n         \"c f 0.6 f 0.2\", \"5x5x5\",\n         \"c f 0.666666666666667 f 0.333333333333333 f 0\", \"6x6x6\",\n         \"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143\", \"7x7x7\",\n         \"c f 0.75 f 0.5 f 0.25 f 0\", \"8x8x8\",\n         \"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111\", \"9x9x9\",\n         \"c f 0.8 f 0.6 f 0.4 f 0.2 f 0\", \"10x10x10\",\n         \"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909\", \"11x11x11\",\n         \"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0\", \"12x12x12\",\n         \"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769\", \"13x13x13\",\n         \"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9\", \"20x20x20\",\n         \"c v 0\", \"skewb\",\n         \"c v 0.275\", \"master skewb\",\n         \"c v 0 v 0.38\", \"professor skewb\",\n         \"c v 0.915641442663986\", \"compy cube\",\n         \"c e 0.707106781186547\", \"helicopter\",\n         \"c v 0.577350269189626\", \"dino\",\n         \"c e 0\", \"little chop\",\n         \"t e 0\", \"pyramorphix\",\n         \"t e 0.346184634065199\", \"mastermorphix\",\n         \"t v 0.333333333333333 v 1.66666666666667\", \"pyraminx\",\n         \"t f 0\", \"Jing pyraminx\",\n         \"t e 0.866025403784437\", \"master paramorphix\",\n         \"d f 0.7\", \"megaminx\",\n         \"d f 0.64 f 0.82\", \"gigaminx\",\n         \"d f 0\", \"pentultimate\",\n         \"d v 0.93796236956\", \"starminx\",\n         \"d f 0.23606797749979\", \"starminx 2\",\n         \"d f 0.447213595499989\", \"pyraminx crystal\",\n         \"d v 0\", \"chopasaurus\",\n         \"d e 0\", \"big chop\",\n         \"o f 0\", \"skewb diamond\",\n         \"o f 0.333333333333333\", \"FTO\",\n         \"o v 0.577350269189626\", \"Christopher's jewel\",\n         \"o e 0\", \"octastar\",\n         \"o v 0.433012701892219\", \"Trajber's octahedron\",\n         \"i f 0\", \"radio chop\",\n         \"i v 0\", \"icosamate\",\n         \"i v 0.18759247376021\", \"icosahedron 2\",\n         \"i v 0.18759247376021 e 0\", \"icosahedron 3\",\n         \"i v 0.84\", \"icosahedron static faces\",\n         \"i v 0.73\", \"icosahedron moving faces\",\n      ] ;\n   }\n   static parsedesc(s:string):any { // parse a text description\n      var a = s.split(/ /).filter(Boolean) ;\n      if (a.length % 2 == 0)\n         return false ;\n      if (a[0] != 'o' && a[0] != 'c' && a[0] != 'i' && a[0] != 'd' && a[0] != 't')\n         return false ;\n      var r = [] ;\n      for (var i=1; i<a.length; i += 2) {\n         if (a[i] != 'f' && a[i] != 'v' && a[i] != 'e')\n            return false ;\n         r.push([a[i], a[i+1]]) ;\n      }\n      return [a[0], r] ;\n   }\n   generatesvg(w:number, h:number, trim:number, threed:boolean):string {\n   // generate svg to interoperate with Lucas twistysim\n      if (w == undefined || h == undefined) {\n         w = 800 ;\n         h = 500 ;\n      }\n      if (trim == undefined)\n         trim = 10 ;\n      w -= 2 * trim ;\n      h -= 2 * trim ;\n      function extendedges(a:Array<Array<number>>, n:number):void {\n         var dx = a[1][0] - a[0][0] ;\n         var dy = a[1][1] - a[0][1] ;\n         var ang = 2*Math.PI/n ;\n         var cosa = Math.cos(ang) ;\n         var sina = Math.sin(ang) ;\n         for (var i=2; i<n; i++) {\n            var ndx = dx * cosa + dy * sina ;\n            dy = dy * cosa - dx * sina ;\n            dx = ndx ;\n            a.push([a[i-1][0]+dx, a[i-1][1]+dy]) ;\n         }\n      }\n      function drawedges(id:string, pts:Array<Array<number>>, color:string)\n                                                                      :string {\n         return \"<polygon id=\\\"\" + id + \"\\\" class=\\\"sticker\\\" style=\\\"fill: \" + color +\n            \"\\\" points=\\\"\" +\n            pts.map(function(p){return p[0] + \" \" + p[1]}).join(\" \") +\n            \"\\\"/>\\n\" ;\n      }\n      // What grips do we need?\n      var needvertexgrips = false ;\n      var neededgegrips = false ;\n      var needfacegrips = false ;\n      for (var i=0; i<this.movesetgeos.length; i++) {\n         var msg = this.movesetgeos[i] ;\n         for (var j=1; j<=3; j += 2) {\n            if (msg[j] == 'v')\n               needvertexgrips = true ;\n            if (msg[j] == 'f')\n               needfacegrips = true ;\n            if (msg[j] == 'e')\n               neededgegrips = true ;\n         }\n      }\n      // Find a net from a given face count.  Walk it, assuming we locate\n      // the first edge from (0,0) to (1,1) and compute the minimum and\n      // maximum vertex locations from this.  Then do a second walk, and\n      // assign the actual geometry.\n      this.genperms() ;\n      var boundarygeo = this.getboundarygeometry() ;\n      var face0 = boundarygeo.facenames[0][0] ;\n      var polyn = face0.length ; // number of vertices; 3, 4, or 5\n      var net = this.net ;\n      if (net == null)\n         throw \"No net?\" ;\n      var edges:any = {} ;\n      var minx = 0 ;\n      var miny = 0 ;\n      var maxx = 1 ;\n      var maxy = 0 ;\n      edges[net[0][0]] = [[1, 0], [0, 0]] ;\n      extendedges(edges[net[0][0]], polyn) ;\n      for (var i=0; i<net.length; i++) {\n         var f0 = net[i][0] ;\n         if (!edges[f0])\n            throw \"Bad edge description; first edge not connected.\" ;\n         for (var j=1; j<net[i].length; j++) {\n            var f1 = net[i][j] ;\n            if (f1 == \"\" || edges[f1])\n               continue ;\n            edges[f1] = [edges[f0][j%polyn], edges[f0][(j+polyn-1)%polyn]] ;\n            extendedges(edges[f1], polyn) ;\n         }\n      }\n      for (var f in edges) {\n         var es = edges[f] ;\n         for (var i=0; i<es.length; i++) {\n            minx = Math.min(minx, es[i][0]) ;\n            maxx = Math.max(maxx, es[i][0]) ;\n            miny = Math.min(miny, es[i][1]) ;\n            maxy = Math.max(maxy, es[i][1]) ;\n         }\n      }\n      var sc = Math.min(w/(maxx-minx), h/(maxy-miny)) ;\n      var xoff = 0.5*(w-sc*(maxx+minx)) ;\n      var yoff = 0.5*(h-sc*(maxy+miny)) ;\n      var geos:any = {} ;\n      var bg = this.getboundarygeometry() ;\n      var edges2:any = {} ;\n      var initv = [[sc+xoff, yoff], [xoff, yoff]] ;\n      edges2[net[0][0]] = initv ;\n      extendedges(edges2[net[0][0]], polyn) ;\n      geos[this.facenames[0][1]] = this.project2d(0, 0,\n                    [new Quat(0, initv[0][0], initv[0][1], 0),\n                     new Quat(0, initv[1][0], initv[1][1], 0)]) ;\n      var connectat = [] ;\n      connectat[0] = 0 ;\n      for (var i=0; i<net.length; i++) {\n         var f0 = net[i][0] ;\n         if (!edges2[f0])\n            throw \"Bad edge description; first edge not connected.\" ;\n         var gfi = -1 ;\n         for (var j=0; j<bg.facenames.length; j++)\n            if (f0 == bg.facenames[j][1]) {\n               gfi = j ;\n               break ;\n            }\n         if (gfi < 0)\n            throw \"Could not find first face name \" + f0 ;\n         var thisface = bg.facenames[gfi][0] ;\n         for (var j=1; j<net[i].length; j++) {\n            var f1 = net[i][j] ;\n            if (f1 == \"\" || edges2[f1])\n               continue ;\n            edges2[f1] = [edges2[f0][j%polyn], edges2[f0][(j+polyn-1)%polyn]] ;\n            extendedges(edges2[f1], polyn) ;\n            // what edge are we at?\n            var caf0 = connectat[gfi] ;\n            var mp = thisface[(caf0+j)%polyn].sum(thisface[(caf0+j+polyn-1)%polyn]).smul(0.5) ;\n            var epi = PuzzleGeometry.findelement(bg.edgenames, mp) ;\n            var edgename = bg.edgenames[epi][1] ;\n            var el = this.splitByFaceNames(edgename, this.facenames) ;\n            var gf1 = el[(f0 == el[0]) ? 1 : 0] ;\n            var gf1i = -1 ;\n            for (var k=0; k<bg.facenames.length; k++) {\n               if (gf1 == bg.facenames[k][1]) {\n                  gf1i = k ;\n                  break ;\n               }\n            }\n            if (gf1i < 0)\n               throw \"Could not find second face name\" ;\n            var otherface = bg.facenames[gf1i][0] ;\n            for (var k=0; k<otherface.length; k++) {\n               var mp2 = otherface[k].sum(otherface[(k+1)%polyn]).smul(0.5) ;\n               if (mp2.dist(mp) <= PuzzleGeometry.eps) {\n                  var p1 = edges2[f0][(j+polyn-1)%polyn] ;\n                  var p2 = edges2[f0][j % polyn] ;\n                  connectat[gf1i] = k ;\n                  geos[gf1] = this.project2d(gf1i, k,\n                          [new Quat(0, p2[0], p2[1], 0), new Quat(0, p1[0], p1[1], 0)]) ;\n                  break ;\n               }\n            }\n         }\n      }\n      // Let's build arrays for faster rendering.  We want to map from geo\n      // base face number to color, and we want to map from geo face number\n      // to 2D geometry.  These can be reused as long as the puzzle overall\n      // orientation and canvas size remains unchanged.\n      var pos = this.getsolved() ;\n      var colormap = [] ;\n      var facegeo = [] ;\n      for (var i=0; i<this.basefacecount; i++) {\n         colormap[i] = this.colors[this.facenames[i][1]] ;\n      }\n      var hix = 0 ;\n      var hiy = 0 ;\n      var rot = Quat.random() ;\n      var basefacecount = this.basefacecount ;\n      if (basefacecount == 4) {\n         rot = new Quat(0.7043069543230507,0.0617237605829268,\n                        0.4546068756768417,0.5417328493446099) ;\n      } else if (basefacecount == 6) {\n         rot = new Quat(0.3419476009844782,0.17612448544695208,\n                        -0.42284908551877964,0.8205185279339757) ;\n      } else if (basefacecount == 8) {\n         rot = new Quat(-0.6523285484575103,0.2707374015470506,\n                        0.6537994145576647,0.27150515611112014) ;\n      } else if (basefacecount == 12) {\n         rot = new Quat(-0.5856747836703331,0.02634133605619232,\n                        0.7075560342412421,0.39453217891103587) ;\n      } else if (basefacecount == 20) {\n         rot = new Quat(0.7052782621769977,0.6377976252204238,\n                        0.30390357803973855,0.05864620549043545) ;\n      }\n      for (var i=0; i<this.faces.length; i++) {\n         var face = this.faces[i] ;\n         face = rot.rotateface(face) ;\n         for (var j=0; j<face.length; j++) {\n            hix = Math.max(hix, Math.abs(face[j].b)) ;\n            hiy = Math.max(hiy, Math.abs(face[j].c)) ;\n         }\n      }\n      var sc2 = Math.min(h / hiy / 2, (w - trim) / hix / 4) ;\n      var that = this ;\n      function mappt2d(fn:number, q:Quat):Array<number> {\n         if (threed) {\n            var xoff = 0.5 * trim + 0.25 * w ;\n            var xmul = (that.baseplanes[fn].rotateplane(rot).d < 0 ? 1 : -1) ;\n            return [trim+w*0.5+xmul*(xoff-q.b*sc2), trim+h*0.5+q.c*sc2] ;\n         } else {\n            var g = geos[that.facenames[fn][1]] ;\n            return [trim+q.dot(g[0])+g[2].b, trim+h-q.dot(g[1])-g[2].c] ;\n         }\n      }\n      for (var i=0; i<this.faces.length; i++) {\n         var face = that.faces[i] ;\n         var facenum = Math.floor(i/that.stickersperface) ;\n         if (threed)\n            face = rot.rotateface(face) ;\n         facegeo.push(face.map((_:Quat)=>mappt2d(facenum, _))) ;\n      }\n      var svg = [] ;\n      // group each base face so we can add a hover element\n      for (var j=0; j<this.basefacecount; j++) {\n         svg.push(\"<g>\") ;\n         svg.push(\"<title>\" + this.facenames[j][1] + \"</title>\\n\") ;\n         for (var ii=0; ii<this.stickersperface; ii++) {\n            var i = j*this.stickersperface+ii ;\n            var cubie = this.facetocubies[i][0] ;\n            var cubieori = this.facetocubies[i][1] ;\n            var cubiesetnum = this.cubiesetnums[cubie] ;\n            var cubieord = this.cubieordnums[cubie] ;\n            var color = this.skipbyori(cubie) ? \"#808080\" : colormap[pos.p[i]] ;\n            var id = this.cubiesetnames[cubiesetnum] +\n                                           \"-l\" + cubieord + \"-o\" + cubieori ;\n            svg.push(drawedges(id, facegeo[i], color)) ;\n         }\n         svg.push(\"</g>\") ;\n      }\n      var svggrips:Array<any> = [] ;\n      function addgrip(onface:number, name:string, pt:Quat, order:number):void {\n         var pt2 = mappt2d(onface, pt) ;\n         for (var i=0; i<svggrips.length; i++)\n            if (Math.hypot(pt2[0]-svggrips[i][0], pt2[1]-svggrips[i][1]) < PuzzleGeometry.eps)\n               return ;\n         svggrips.push([pt2[0], pt2[1], name, order]) ;\n      }\n      for (var i=0; i<this.faceplanes.length; i++) {\n         var baseface = this.facenames[i][0] ;\n         var facecoords = baseface ;\n         if (threed)\n            facecoords = rot.rotateface(facecoords) ;\n         if (needfacegrips) {\n            var pt = this.faceplanes[i][0] ;\n            if (threed)\n               pt = pt.rotatepoint(rot) ;\n            addgrip(i, this.faceplanes[i][1], pt, polyn) ;\n         }\n         for (var j=0; j<baseface.length; j++) {\n            if (neededgegrips) {\n               var mp = baseface[j].sum(\n                                 baseface[(j+1)%baseface.length]).smul(0.5) ;\n               var ep = PuzzleGeometry.findelement(this.edgenames, mp) ;\n               var mpc = facecoords[j].sum(\n                                 facecoords[(j+1)%baseface.length]).smul(0.5) ;\n               addgrip(i, this.edgenames[ep][1], mpc, 2) ;\n            }\n            if (needvertexgrips) {\n               var vp = PuzzleGeometry.findelement(\n                                              this.vertexnames, baseface[j]) ;\n               addgrip(i, this.vertexnames[vp][1], facecoords[j],\n                       this.cornerfaces) ;\n            }\n         }\n      }\n      var html = '<svg id=\"svg\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 800 500\">\\n' +\n      '<style type=\"text/css\"><![CDATA[' +\n      '.sticker { stroke: #000000; stroke-width: 1px; }' +\n      ']]></style>\\n' +\n      svg.join('') + \"</svg>\" ;\n      this.svggrips = svggrips ;\n      return html ;\n   }\n}\n","import { Perm } from \"./Perm\" ;\nclass FactoredNumber {\n   mult:Array<number>\n   constructor() {\n      this.mult = [] ;\n   }\n   multiply(n:number):void {\n      for (var f=2; f*f<=n; f++) {\n         while (n % f == 0) {\n            if (undefined != this.mult[f])\n               this.mult[f]++ ;\n            else\n               this.mult[f] = 1 ;\n            n /= f ;\n         }\n      }\n      if (n > 1) {\n         if (undefined != this.mult[n])\n            this.mult[n]++ ;\n         else\n            this.mult[n] = 1 ;\n      }\n   }\n   toString():string {\n      var r = \"\" ;\n      for (var i=0; i<this.mult.length; i++)\n         if (undefined != this.mult[i]) {\n            if (r != \"\")\n               r += \"*\" ;\n            r += i ;\n            if (this.mult[i] > 1)\n               r += \"^\" + this.mult[i] ;\n         }\n      return r ;\n   }\n}\nexport class SchreierSims {\n   static schreiersims(g:Array<Perm>, disp:(s:string)=>void):number {\n      var n = g[0].p.length ;\n      var e = Perm.e(n) ;\n      var sgs:Array<Array<Perm>> = [] ;\n      var sgsi:Array<Array<Perm>> = [] ;\n      var sgslen:Array<Array<number>> = [] ;\n      var Tk:Array<Array<Perm>> = [] ;\n      var Tklen:Array<Array<number>> = [] ;\n      function resolve(p:Perm):boolean {\n         for (var i=p.p.length-1; i>=0; i--) {\n            var j = p.p[i] ;\n            if (j != i) {\n               if (!sgs[i][j])\n                  return false ;\n               p = p.mul(sgsi[i][j]) ;\n            }\n         }\n         return true ;\n      }\n      function knutha(k:number, p:Perm, len:number):void {\n         Tk[k].push(p) ;\n         Tklen[k].push(len) ;\n         for (var i=0; i<sgs[k].length; i++)\n            if (sgs[k][i])\n               knuthb(k, sgs[k][i].mul(p), len+sgslen[k][i]) ;\n      }\n      function knuthb(k:number, p:Perm, len:number):void {\n         var j = p.p[k] ;\n         if (!sgs[k][j]) {\n            sgs[k][j] = p ;\n            sgsi[k][j] = p.inv() ;\n            sgslen[k][j] = len ;\n            for (var i=0; i<Tk[k].length; i++)\n               knuthb(k, p.mul(Tk[k][i]), len+Tklen[k][i]) ;\n            return ;\n         }\n         var p2 = p.mul(sgsi[k][j]) ;\n         if (!resolve(p2))\n            knutha(k-1, p2, len+sgslen[k][j]) ;\n      }\n      function getsgs():number {\n         sgs = [] ;\n         sgsi = [] ;\n         Tk = [] ;\n         sgslen = [] ;\n         Tklen = [] ;\n         for (var i=0; i<n; i++) {\n            sgs.push([]) ;\n            sgsi.push([]) ;\n            sgslen.push([]) ;\n            Tk.push([]) ;\n            Tklen.push([]) ;\n            sgs[i][i] = e ;\n            sgsi[i][i] = e ;\n            sgslen[i][i] = 0 ;\n         }\n         var avgs = [] ;\n         var none = 0 ;\n         var sz = 1 ;\n         for (var i=0; i<g.length; i++) {\n            knutha(n-1, g[i], 1) ;\n            sz = 1 ;\n            var tks = 0 ;\n            var sollen = 0 ;\n            var avgs = [] ;\n            var mults = new FactoredNumber() ;\n            for (var j=0; j<n; j++) {\n               var cnt = 0 ;\n               var lensum = 0 ;\n               for (var k=0; k<n; k++)\n                  if (sgs[j][k]) {\n                     cnt++ ;\n                     lensum += sgslen[j][k] ;\n                     if (j != k)\n                        none++ ;\n                  }\n               tks += Tk[j].length ;\n               sz *= cnt ;\n               if (cnt > 1)\n                  mults.multiply(cnt) ;\n               var avg = lensum / cnt ;\n               avgs.push(avg) ;\n               sollen += avg ;\n            }\n            disp(\"\" + i + \": sz \" + sz + \" T \" + tks + \" sol \" + sollen + \" none \" + none + \" mults \" + mults) ;\n         }\n         return sz ;\n      }\n      return getsgs() ;\n   }\n}\n","export {\n  Quat\n} from \"./Quat\"\nexport {\n   PlatonicGenerator\n} from \"./PlatonicGenerator\"\nexport {\n   PuzzleGeometry\n} from \"./PuzzleGeometry\"\nexport {\n   Perm\n} from \"./Perm\"\nexport {\n   OrbitDef, OrbitsDef, Orbit, Transformation, VisibleState\n} from \"./PermOriSet\"\nexport {\n   SchreierSims\n} from \"./SchreierSims\" ;\n"],"sourceRoot":""}